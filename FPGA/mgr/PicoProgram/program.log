KCPSM6 Assembler log file for program 'C:\studia\MGR\FPGA\mgr\PicoProgram\program.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 06 Dec 2015
Assembly timestamp: 19:10:07

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 2DB hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 732
Memory locations available: 3364


Assembly listing

 Addr Code                          Instruction

 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Copyright © 2011-2013, Xilinx, Inc.
 000                                ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 000                                ; protected under U.S. and international copyright and other intellectual property laws.
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; Disclaimer:
 000                                ; This disclaimer is not a license and does not grant any rights to the materials
 000                                ; distributed herewith. Except as otherwise provided in a valid license issued to
 000                                ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 000                                ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 000                                ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 000                                ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 000                                ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 000                                ; (whether in contract or tort, including negligence, or under any other theory
 000                                ; of liability) for any loss or damage of any kind or nature related to, arising
 000                                ; under or in connection with these materials, including for any direct, or any
 000                                ; indirect, special, incidental, or consequential loss or damage (including loss
 000                                ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 000                                ; of any action brought by a third party) even if such damage or loss was
 000                                ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 000                                ;
 000                                ; CRITICAL APPLICATIONS
 000                                ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 000                                ; application requiring fail-safe performance, such as life-support or safety
 000                                ; devices or systems, Class III medical devices, nuclear facilities, applications
 000                                ; related to the deployment of airbags, or any other applications that could lead
 000                                ; to death, personal injury, or severe property or environmental damage
 000                                ; (individually and collectively, "Critical Applications"). Customer assumes the
 000                                ; sole risk and liability of any use of Xilinx products in Critical Applications,
 000                                ; subject only to applicable laws and regulations governing limitations on product
 000                                ; liability.
 000                                ;
 000                                ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ;
 000                                ;             _  ______ ____  ____  __  __  __
 000                                ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 000                                ;            | ' / |   | |_) \___ \| |\/| | '_ \
 000                                ;            | . \ |___|  __/ ___) | |  | | (_) )
 000                                ;            |_|\_\____|_|   |____/|_|  |_|\___/
 000                                ;
 000                                ;
 000                                ; KCPSM6 reference design using 'uart_tx6' and 'uart_rx6' macros.
 000                                ;
 000                                ; Ken Chapman - Xilinx Ltd
 000                                ;
 000                                ;      11th May 2011 - Initial version
 000                                ;   6th October 2011 - Corrections to comments only
 000                                ;    23rd April 2012 - UART interface routines placed into 'uart_interface_routines.psm'
 000                                ;                      to facilitate reuse and provide an INCLUDE directive example.
 000                                ; 7th September 2012 - Corrections to comments only
 000                                ;    12th March 2013 - Constant directives defining ASCII control characters removed
 000                                ;                        (pre-defined in KCPSM6 assembler v2.43 or later).
 000                                ;     28th June 2013 - Corrections to comment only
 000                                ;
 000                                ;
 000                                ; INTRODUCTION
 000                                ;
 000                                ; This program interacts with the 'uart_tx6' and 'uart_rx6' macros providing some simple
 000                                ; and fundamental examples of UART based communication. As such, this example is intended
 000                                ; to display messages on a PC based terminal (e.g. PicoTerm or HyperTerminal) and receive
 000                                ; inputs typed on a keyboard by the user.
 000                                ;
 000                                ; The user is prompted to enter a 4-digit hexadecimal value which KCPSM6 converts to
 000                                ; decimal and displays if it is valid. It is hoped that this will also provide you with
 000                                ; several routines that you will find useful in your own programs.
 000                                ;
 000                                ; Please see 'UART6_User_Guide_30Sept12.pdf' for more detailed descriptions of the
 000                                ; hardware circuit. The 'UART_TX' and 'UART_RX' routines that form the software interface
 000                                ; with the macros are contained in 'uart_interface_routines.psm' together with a set of
 000                                ; constants which define the allocation of I/O ports and the signals within them. The
 000                                ; 'uart_interface_routines.psm' also presents an example of using the INCLUDE directive
 000                                ; introduced with KCPSM6 Assembler v2.00.
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Port definitions
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; The only I/O ports used in this design are those that interface with the UART macros.
 000                                ; CONSTANT directives defining the port addresses and the allocation of signals within
 000                                ; those ports are defined in 'uart_interface_routines.psm'.
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Special Register usage
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; No registers are given special names in this program.
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Scratch Pad Memory Locations
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                CONSTANT hex_value0, 00                                ;16-bit value (lower byte)
 000                                CONSTANT hex_value1, 01                                ;16-bit value (upper byte)
 000                                ;
 000                                CONSTANT decimal0, 02                                  ;5 digit decimal value
 000                                CONSTANT decimal1, 03                                  ;  Suitable for 16-bit values up to
 000                                CONSTANT decimal2, 04                                  ;   65,536
 000                                CONSTANT decimal3, 05
 000                                CONSTANT decimal4, 06
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Useful data constants
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Initialise the system
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; A delay of 1 second is implemented which is intended to give time for all the hardware
 000                                ; to settle into a stable condition before starting to doing anything. This can be
 000                                ; particularly beneficial when dealing with long cables where serial lines can take some
 000                                ; time to reach the initial idle state following power being applied.
 000                                ;
 000  200C6             cold_start: CALL 0C6[delay_1s]                                     ;
 001                                ;
 001  200E2                         CALL 0E2[reset_UART_macros]                            ;Reset buffers in UART macros
 002                                ;
 002                                ;
 002                                ; Initialised terminal display and display welcome messages
 002                                ;
 002                                ;CALL clear_screen
 002                                ;CALL welcome_message
 002                                ;
 002                                ;
 002                                ;------------------------------------------------------------------------------------------
 002                                ; Main Program
 002                                ;------------------------------------------------------------------------------------------
 002                                ;
 002                                ;
 002                          main: 
 002                                ;jump UART_THREAD
 002                                ;jump LPC_THREAD
 002  01708              IR_petla1: LOAD s7, 08
 003  01F1B                         LOAD sF, 1B[ESC]
 004  200EE                         CALL 0EE[LCD_send]
 005  202BD                         CALL 2BD[ini_banner]
 006  01A00              IR_petla2: LOAD sA, 00[00000000'b]
 007  01B00                         LOAD sB, 00[00000000'b]
 008  01C00                         LOAD sC, 00[00000000'b]
 009  0900B              IR_czekaj: INPUT s0, 0B[IR_PORT]
 00A  0D001                         TEST s0, 01[00000001'b]
 00B  3A009                         JUMP C, 009[IR_czekaj]
 00C  200BE                         CALL 0BE[delay_ir_1_8_bit]
 00D  01403                 IR_rx1: LOAD s4, 03                                            ;8-bits to transmit and receive
 00E  200B2           next_IR_bit1: CALL 0B2[my_delay_ir_bit]                              ;prepare next bit to transmit
 00F  0930B                         INPUT s3, 0B[IR_PORT]                                  ;read input bit
 010  0D301                         TEST s3, 01[00000001'b]                                ;carry flag becomes value of received bit
 011  14A00                         SLA sA                                                 ;shift new data into result and move to next transmit bit
 012  19401                         SUB s4, 01                                             ;count bits
 013  3600E                         JUMP NZ, 00E[next_IR_bit1]                             ;repeat until last bit
 014  01405                 IR_rx2: LOAD s4, 05                                            ;8-bits to transmit and receive
 015  200B2           next_IR_bit2: CALL 0B2[my_delay_ir_bit]                              ;prepare next bit to transmit
 016  0930B                         INPUT s3, 0B[IR_PORT]                                  ;read input bit
 017  0D301                         TEST s3, 01[00000001'b]                                ;carry flag becomes value of received bit
 018  14B00                         SLA sB                                                 ;shift new data into result and move to next transmit bit
 019  19401                         SUB s4, 01                                             ;count bits
 01A  36015                         JUMP NZ, 015[next_IR_bit2]                             ;repeat until last bit
 01B  01406                 IR_rx3: LOAD s4, 06                                            ;8-bits to transmit and receive
 01C  200B2           next_IR_bit3: CALL 0B2[my_delay_ir_bit]                              ;prepare next bit to transmit
 01D  0930B                         INPUT s3, 0B[IR_PORT]                                  ;read input bit
 01E  0D301                         TEST s3, 01[00000001'b]                                ;carry flag becomes value of received bit
 01F  14C00                         SLA sC                                                 ;shift new data into result and move to next transmit bit
 020  19401                         SUB s4, 01                                             ;count bits
 021  3601C                         JUMP NZ, 01C[next_IR_bit3]                             ;repeat until last bit
 022  20048                         CALL 048[send_CR]
 023  004A0                         LOAD s4, sA
 024  2004C                         CALL 04C[send_hex_byte]
 025  2004A                         CALL 04A[send_space]
 026  004B0                         LOAD s4, sB
 027  2004C                         CALL 04C[send_hex_byte]
 028  2004A                         CALL 04A[send_space]
 029  004C0                         LOAD s4, sC
 02A  2004C                         CALL 04C[send_hex_byte]
 02B                                ; Filtr "0"
 02B  006A0                         LOAD s6, sA
 02C  19607                         SUB s6, 07
 02D  3E006                         JUMP NC, 006[IR_petla2]
 02E                                ;CALL send_space
 02E                                ;load s4, s6
 02E                                ;call send_hex_byte
 02E                                ;TEST s6, 11111111'b
 02E                                ;JUMP NZ, IR_petla2
 02E                                ;
 02E  2010D           after_filter: CALL 10D[convert_send]
 02F  36006                         JUMP NZ, 006[IR_petla2]
 030  2B01A             LPC_THREAD: OUTPUTK 01[LPC_ready_syg], A[LPC_IN_ready_port]
 031  09009                         INPUT s0, 09[LPC_IN_data_valid_port]
 032  0D001                         TEST s0, 01[LPC_data_valid_syg]                        ;Z=0 and C=1 when data present
 033  32030                         JUMP Z, 030[LPC_THREAD]
 034  09508                         INPUT s5, 08[LPC_IN_data_port]
 035  2B00A            LPC_DV_down: OUTPUTK 00[00000000'b], A[LPC_IN_ready_port]
 036  09009                         INPUT s0, 09[LPC_IN_data_valid_port]                   ;Sprawdza czy driver odebra³ dane
 037  0D001                         TEST s0, 01[LPC_data_valid_syg]
 038  3A035                         JUMP C, 035[LPC_DV_down]
 039  2016D                         CALL 16D[which_banner]
 03A  200D6                         CALL 0D6[delay_5s]
 03B  22002                         JUMP 002[IR_petla1]
 03C  200EE           LPC_LCD_send: CALL 0EE[LCD_send]
 03D  200F8                         CALL 0F8[LPC_send]
 03E  19701                         SUB s7, 01
 03F  25000                         RETURN 
 040  09000            UART_THREAD: INPUT s0, 00[UART_status_port]
 041  0D008                         TEST s0, 08[UART_Rx_data_present]                      ;Z=0 and C=1 when data present
 042  32040                         JUMP Z, 040[UART_THREAD]
 043  09501                         INPUT s5, 01[UART_RX6_input_port]
 044  00F50                         LOAD sF, s5
 045                                ;CALL UART_TX
 045  200F8                         CALL 0F8[LPC_send]
 046  200EE                         CALL 0EE[LCD_send]
 047  22040                         JUMP 040[UART_THREAD]
 048                                ;
 048                                ;
 048                                ;------------------------------------------------------------------------------------------
 048                                ; Send Carriage Return to UART
 048                                ;------------------------------------------------------------------------------------------
 048                                ;
 048                                ; Registers used s0, s1, s2, and s
 048  0150D                send_CR: LOAD s5, 0D[CR]
 049  220E9                         JUMP 0E9[UART_TX]                                      ;includes RETURN
 04A                                ;
 04A                                ;
 04A                                ;------------------------------------------------------------------------------------------
 04A                                ; Send a Space to UART
 04A                                ;------------------------------------------------------------------------------------------
 04A                                ;
 04A                                ; Registers used s0, s1, s2, and s5.
 04A                                ;
 04A  01520             send_space: LOAD s5, 20[" "]
 04B  220E9                         JUMP 0E9[UART_TX]                                      ;includes RETURN
 04C                                ;
 04C                                ;
 04C                                ;------------------------------------------------------------------------------------------
 04C                                ; Send Hex Value of 16-bit word to UART
 04C                                ;------------------------------------------------------------------------------------------
 04C                                ;
 04C                                ; Value provided in register pair [sB,sA] is sent as ASCII HEX to the UART
 04C                                ; transmitter.
 04C                                ;
 04C                                ; Registers used s0, s1, s2, s4, s5, sA and sB.
 04C                                ;
 04C                                ;
 04C                                ;------------------------------------------------------------------------------------------
 04C                                ; Send Hex Value of Byte to UART
 04C                                ;------------------------------------------------------------------------------------------
 04C                                ;
 04C                                ; Value provided in register 's4' is sent as ASCII HEX to the UART transmitter.
 04C                                ;
 04C                                ; Registers used s0, s4 (preserved) and s5.
 04C                                ;
 04C  00540          send_hex_byte: LOAD s5, s4                                            ;isolate upper nibble
 04D  1450E                         SR0 s5
 04E  1450E                         SR0 s5
 04F  1450E                         SR0 s5
 050  1450E                         SR0 s5
 051  20058                         CALL 058[hex_to_ASCII]                                 ; convert to ASCII
 052  200E9                         CALL 0E9[UART_TX]                                      ;send upper digit to UART
 053  00540                         LOAD s5, s4                                            ;isolate lower nibble
 054  0350F                         AND s5, 0F
 055  20058                         CALL 058[hex_to_ASCII]                                 ; convert to ASCII
 056  200E9                         CALL 0E9[UART_TX]                                      ;send lower digit to UART
 057  25000                         RETURN 
 058                                ;
 058                                ; Convert value 00 to 0F provided in 's5' into ASCII character in 's5'
 058                                ;
 058                                ; Register used s5
 058                                ;
 058  1950A           hex_to_ASCII: SUB s5, 0A                                             ;test if value is in range 0 to 9
 059  3A05B                         JUMP C, 05B[number_char]
 05A  11507                         ADD s5, 07                                             ;ASCII char A to F in range 41 to 46
 05B  1153A            number_char: ADD s5, 3A                                             ;ASCII char 0 to 9 in range 30 to 40
 05C  25000                         RETURN 
 05D                                ;
 05D                                ;
 05D                                ;------------------------------------------------------------------------------------------
 05D                                ; Converts character to upper case
 05D                                ;------------------------------------------------------------------------------------------
 05D                                ;
 05D                                ; Tests and converts character in 's5' (if necessary).
 05D                                ;
 05D                                ; To convert character to upper case
 05D                                ;
 05D                                ; If the character is in the range 'a' to 'z', it is converted
 05D                                ; to the equivalent upper case character in the range 'A' to 'Z'.
 05D                                ; All other characters remain unchanged.
 05D                                ;
 05D  1D561             upper_case: COMPARE s5, 61["a"]                                    ;eliminate character codes below 'a' (61 hex)
 05E  39000                         RETURN C
 05F  1D57B                         COMPARE s5, 7B                                         ;eliminate character codes above 'z' (7A hex)
 060  3D000                         RETURN NC
 061  035DF                         AND s5, DF[11011111'b]                                 ;force bit5 Low to convert to upper case
 062  25000                         RETURN 
 063                                ;
 063                                ;
 063                                ;------------------------------------------------------------------------------------------
 063                                ; Convert ASCII character to an equivalent HEX value.
 063                                ;------------------------------------------------------------------------------------------
 063                                ;
 063                                ; Converts the ASCII character presented in 's5' to an equivalent HEX value.
 063                                ; If character is not valid for hex, then CARRY is set on return.
 063                                ;
 063                                ; Register used s5
 063                                ;
 063  115B9           ASCII_to_hex: ADD s5, B9                                             ;test for above ASCII code 46 ('F')
 064  39000                         RETURN C
 065  195E9                         SUB s5, E9                                             ;normalise 0 to 9 with A-F in 11 to 16 hex
 066  39000                         RETURN C                                               ;reject below ASCII code 30 ('0')
 067  19511                         SUB s5, 11                                             ;isolate A-F down to 00 to 05 hex
 068  3E06D                         JUMP NC, 06D[ASCII_letter]
 069  11507                         ADD s5, 07                                             ;test for above ASCII code 46 ('F')
 06A  39000                         RETURN C
 06B  195F6                         SUB s5, F6                                             ;convert to range 00 to 09
 06C  25000                         RETURN 
 06D  1150A           ASCII_letter: ADD s5, 0A                                             ;convert to range 0A to 0F
 06E  25000                         RETURN 
 06F                                ;
 06F                                ;
 06F                                ;------------------------------------------------------------------------------------------
 06F                                ; Read ASCII-HEX value up to 8-digits (for 32-bit value) from UART
 06F                                ;------------------------------------------------------------------------------------------
 06F                                ;
 06F                                ; Read up to 8 hex characters from UART and convert to a binary value in the [sD,sC,sB,sA]
 06F                                ; register set. The number of characters to be read must be defined in sE. When less than
 06F                                ; 8 characters are read the value is returned in the least significant bits of the register
 06F                                ; set with the 8-bits above the defined value being zero to ensure ensuring that the upper
 06F                                ; nibble will be zero if an odd number of digits are read.
 06F                                ;
 06F                                ; If any character received from the UART is not in the range 0 to F then the routine will
 06F                                ; end immediately with the CARRY flag set and this should be checked by the calling process
 06F                                ; upon return.
 06F                                ;
 06F  01A00           obtain_value: LOAD sA, 00                                            ;initialise potentially unused bits to zero
 070  20104           obtain_digit: CALL 104[UART_RX]                                      ;wait for a character and return in s5
 071  32070                         JUMP Z, 070[obtain_digit]                              ;continue to wait if timeout occurs
 072  200E9                         CALL 0E9[UART_TX]                                      ;echo character as entered
 073  200E9                         CALL 0E9[UART_TX]
 074  200E9                         CALL 0E9[UART_TX]
 075  2005D                         CALL 05D[upper_case]                                   ;convert to upper case if necessary
 076  20063                         CALL 063[ASCII_to_hex]                                 ;convert value in s5 to hex nibble
 077  39000                         RETURN C                                               ;If invalid hex digit then return immediately
 078  01004                         LOAD s0, 04[4'd]                                       ;shift [sD,sC,sB,sA] left by 4 bits
 079  14A06            build_value: SL0 sA                                                 ;  to make space for new digit value
 07A  14B00                         SLA sB
 07B  14C00                         SLA sC
 07C  14D00                         SLA sD
 07D  19001                         SUB s0, 01[1'd]
 07E  36079                         JUMP NZ, 079[build_value]
 07F  04A50                         OR sA, s5                                              ;merge value of new digit into existing value
 080  19E01                         SUB sE, 01                                             ;count number of digits obtained
 081  36070                         JUMP NZ, 070[obtain_digit]
 082  25000                         RETURN 
 083                                ;
 083                                ;
 083                                ;------------------------------------------------------------------------------------------
 083                                ; Send integer in decimal format to UART Tx
 083                                ;------------------------------------------------------------------------------------------
 083                                ;
 083                                ; The 16-bit value provided in [s3,s2] should be a positive integer and will be displayed
 083                                ; using 1 to 5 digits for values up to 65535 (i.e. leading zeros are blanked).
 083                                ;
 083                                ;
 083  1D200           send_integer: COMPARE s2, 00                                         ;test for special case of zero
 084  1F300                         COMPARECY s3, 00
 085  32093                         JUMP Z, 093[zero_integer]
 086                                ;
 086  20096                         CALL 096[integer16_to_BCD]                             ;Convert to BCD in SPM
 087                                ;
 087  01A06                         LOAD sA, 06[decimal4]                                  ;pointer to BCD in SPM
 088  01B00                         LOAD sB, 00[0'd]                                       ;flag for leading zero blanking
 089  0A5A0      send_integer_loop: FETCH s5, (sA)
 08A  10B50                         ADD sB, s5                                             ;make sB non-zero to stop blanking
 08B  1DB00                         COMPARE sB, 00[0'd]                                    ;Test for blanking
 08C  3208F                         JUMP Z, 08F[next_int_digit]
 08D  11530                         ADD s5, 30["0"]                                        ;convert to ASCII
 08E  200E9                         CALL 0E9[UART_TX]                                      ;send digit
 08F  1DA02         next_int_digit: COMPARE sA, 02[decimal0]
 090  31000                         RETURN Z
 091  19A01                         SUB sA, 01[1'd]                                        ;move pointer to next digit
 092  22089                         JUMP 089[send_integer_loop]
 093                                ;
 093  01530           zero_integer: LOAD s5, 30["0"]                                       ;special response for zero
 094  200E9                         CALL 0E9[UART_TX]
 095  25000                         RETURN 
 096                                ;
 096                                ;
 096                                ;------------------------------------------------------------------------------------------
 096                                ; 16-bit integer to BCD conversion
 096                                ;------------------------------------------------------------------------------------------
 096                                ;
 096                                ; Convert the 16 bit value up to FFFF hex in register set [s3,s2]
 096                                ; into the BCD decimal equivalent up to 65,535 located in the scratch pad memory
 096                                ; locations 'decimal0' to 'decimal4' which must be in ascending locations.
 096                                ;
 096                                ; Each digit is formed in turn starting with the least significant. The value
 096                                ; contained in [s3,s2] is divided by 10 and the remainder of that integer division
 096                                ; is the value of each digit in the range 0 to 9.
 096                                ;
 096                                ; Registers used s0,s2,s3,s4,s8,s9,sA,sB
 096                                ;
 096  01402       integer16_to_BCD: LOAD s4, 02[decimal0]                                  ;pointer for LS-Digit in scratch pad memory
 097  2009D        int_to_BCD_loop: CALL 09D[divide_16bit_by_10]
 098  2EA40                         STORE sA, (s4)                                         ;remainder is the digit value
 099  1D406                         COMPARE s4, 06[decimal4]                               ;test for MS-Digit completed
 09A  31000                         RETURN Z
 09B  11401                         ADD s4, 01[1'd]                                        ;advance pointer to next digit
 09C  22097                         JUMP 097[int_to_BCD_loop]
 09D                                ;
 09D                                ; Divide 16-bit binary integer by 10
 09D                                ;
 09D                                ; The value to be divided by 10 should be provided in register set [s3,s2].
 09D                                ; The routine will return the integer result [s3,s2]/10 back in[s3,s2]
 09D                                ; with any remainder in (0 to 9) in register sA.
 09D                                ;
 09D                                ; Registers used s0,s2,s3,s8,s9,sA,sB
 09D                                ;
 09D  00A20     divide_16bit_by_10: LOAD sA, s2                                            ;copy input value into [sB,sA]
 09E  00B30                         LOAD sB, s3
 09F  01200                         LOAD s2, 00                                            ;clear division result
 0A0  01300                         LOAD s3, 00
 0A1  019A0                         LOAD s9, A0                                            ;initialise [s9,s8] with '10' in MSBs
 0A2  01800                         LOAD s8, 00
 0A3  0100D                         LOAD s0, 0D[13'd]                                      ;13 subtract and shift iterations to be performed
 0A4  18A80             div10_loop: SUB sA, s8                                             ;perform 16-bit subtract [sB,sA]-[s9,s8]
 0A5  1AB90                         SUBCY sB, s9
 0A6  3A0A9                         JUMP C, 0A9[div10_restore]                             ;if carry then could not subtract from total
 0A7  14207                         SL1 s2                                                 ;shift '1' into result because subtract ok
 0A8  220AC                         JUMP 0AC[div10_shifts]
 0A9  10A80          div10_restore: ADD sA, s8                                             ;perform 16-bit addition [sB,sA]+[s9,s8]
 0AA  12B90                         ADDCY sB, s9                                           ;to restore total
 0AB  14206                         SL0 s2                                                 ;shift '0' into result because could no subtract
 0AC  14300           div10_shifts: SLA s3                                                 ;complete 16-bit shift left into [s3,s2]
 0AD  1490E                         SR0 s9                                                 ;divide '10' value by 2 (shift right 1 place)
 0AE  14808                         SRA s8
 0AF  19001                         SUB s0, 01                                             ;count iterations
 0B0  31000                         RETURN Z                                               ;on return the remainder of division is in sA
 0B1  220A4                         JUMP 0A4[div10_loop]
 0B2                                ;
 0B2                                ;
 0B2                                ;------------------------------------------------------------------------------------------
 0B2                                ; Include PSM files
 0B2                                ;------------------------------------------------------------------------------------------
 0B2                                ;
 0B2                                ; The INCLUDE directive enables commonly routines to be kept in their own PSM files and
 0B2                                ; easily reused in different programs (i.e. avoiding 'cut and paste'). It also allows
 0B2                                ; each PSM to remain a more manageable size.
 0B2                                ;
 0B2                                ;
 0B2  01200        my_delay_ir_bit: LOAD s2, 00
 0B3  01122                         LOAD s1, 22
 0B4  010BA                         LOAD s0, BA
 0B5  220DC                         JUMP 0DC[software_delay]
 0B6  01200           delay_ir_bit: LOAD s2, 00
 0B7  01122                         LOAD s1, 22
 0B8  010BA                         LOAD s0, BA
 0B9  220DC                         JUMP 0DC[software_delay]
 0BA  01200      delay_ir_half_bit: LOAD s2, 00
 0BB  01111                         LOAD s1, 11
 0BC  0105D                         LOAD s0, 5D
 0BD  220DC                         JUMP 0DC[software_delay]
 0BE  01200       delay_ir_1_8_bit: LOAD s2, 00
 0BF  01104                         LOAD s1, 04
 0C0  01057                         LOAD s0, 57
 0C1  220DC                         JUMP 0DC[software_delay]
 0C2  0121E            delay_200ms: LOAD s2, 1E
 0C3  01184                         LOAD s1, 84
 0C4  01010                         LOAD s0, 10
 0C5  220DC                         JUMP 0DC[software_delay]
 0C6  0125F               delay_1s: LOAD s2, 5F
 0C7  0115E                         LOAD s1, 5E
 0C8  01010                         LOAD s0, 10
 0C9  220DC                         JUMP 0DC[software_delay]
 0CA                                ;
 0CA                                ; 2ms is 10,000 x 200ns     (10,000 = 002710 hex)
 0CA  01200              delay_1ms: LOAD s2, 00                                            ;2ms !
 0CB  01127                         LOAD s1, 27
 0CC  01010                         LOAD s0, 10
 0CD  220DC                         JUMP 0DC[software_delay]
 0CE                                ;
 0CE                                ; 40ms is 200,000 x 200ns     (200,000 = 030D40 hex)
 0CE                                ;
 0CE  01203             delay_40ms: LOAD s2, 03
 0CF  0110D                         LOAD s1, 0D
 0D0  01040                         LOAD s0, 40
 0D1  220DC                         JUMP 0DC[software_delay]
 0D2                                ;
 0D2                                ;
 0D2                                ; 2s is 10,000,000 x 200ns     (10,000,000 = 989680 hex)
 0D2                                ;
 0D2  01298               delay_2s: LOAD s2, 98
 0D3  01196                         LOAD s1, 96
 0D4  01080                         LOAD s0, 80
 0D5  220DC                         JUMP 0DC[software_delay]
 0D6  200C6               delay_5s: CALL 0C6[delay_1s]
 0D7  200C6                         CALL 0C6[delay_1s]
 0D8  200C6                         CALL 0C6[delay_1s]
 0D9  200C6                         CALL 0C6[delay_1s]
 0DA  200C6                         CALL 0C6[delay_1s]
 0DB  25000                         RETURN 
 0DC                                ;
 0DC                                ; The delay loop decrements [s2,s1,s0] until it reaches zero
 0DC                                ; Each decrement cycle is 5 instructions which is 10 clock cycles (100ns at 100MHz)
 0DC                                ;
 0DC  00000         software_delay: LOAD s0, s0                                            ;pad loop to make it 10 clock cycles (5 instructions) 200ns u mnie
 0DD  19001                         SUB s0, 01[1'd]
 0DE  1B100                         SUBCY s1, 00[0'd]
 0DF  1B200                         SUBCY s2, 00[0'd]
 0E0  360DC                         JUMP NZ, 0DC[software_delay]
 0E1  25000                         RETURN 
 0E2                                ; Include routines that implement interface with UART macros.
 0E2                                ; -----------------------------------------------------------
 0E2                                ;
 0E2                                INCLUDE "C:\studia\MGR\FPGA\mgr\PicoProgram\communication_routines.psm"["communication_routines.psm"]
 0E2                                ;
 0E2                                ;------------------------------------------------------------------------------------------
 0E2                                ; Copyright © 2011-2012, Xilinx, Inc.
 0E2                                ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 0E2                                ; protected under U.S. and international copyright and other intellectual property laws.
 0E2                                ;------------------------------------------------------------------------------------------
 0E2                                ;
 0E2                                ; Disclaimer:
 0E2                                ; This disclaimer is not a license and does not grant any rights to the materials
 0E2                                ; distributed herewith. Except as otherwise provided in a valid license issued to
 0E2                                ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 0E2                                ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 0E2                                ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 0E2                                ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 0E2                                ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 0E2                                ; (whether in contract or tort, including negligence, or under any other theory
 0E2                                ; of liability) for any loss or damage of any kind or nature related to, arising
 0E2                                ; under or in connection with these materials, including for any direct, or any
 0E2                                ; indirect, special, incidental, or consequential loss or damage (including loss
 0E2                                ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 0E2                                ; of any action brought by a third party) even if such damage or loss was
 0E2                                ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 0E2                                ;
 0E2                                ; CRITICAL APPLICATIONS
 0E2                                ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 0E2                                ; application requiring fail-safe performance, such as life-support or safety
 0E2                                ; devices or systems, Class III medical devices, nuclear facilities, applications
 0E2                                ; related to the deployment of airbags, or any other applications that could lead
 0E2                                ; to death, personal injury, or severe property or environmental damage
 0E2                                ; (individually and collectively, "Critical Applications"). Customer assumes the
 0E2                                ; sole risk and liability of any use of Xilinx products in Critical Applications,
 0E2                                ; subject only to applicable laws and regulations governing limitations on product
 0E2                                ; liability.
 0E2                                ;
 0E2                                ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 0E2                                ;
 0E2                                ;------------------------------------------------------------------------------------------
 0E2                                ;
 0E2                                ;             _  ______ ____  ____  __  __  __
 0E2                                ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 0E2                                ;            | ' / |   | |_) \___ \| |\/| | '_ \
 0E2                                ;            | . \ |___|  __/ ___) | |  | | (_) )
 0E2                                ;            |_|\_\____|_|   |____/|_|  |_|\___/
 0E2                                ;
 0E2                                ;
 0E2                                ;                PicoBlaze Reference Design.
 0E2                                ;
 0E2                                ;
 0E2                                ; Ken Chapman - Xilinx Ltd
 0E2                                ;
 0E2                                ; 23rd April 2012 - Initial Release
 0E2                                ; 24th July 2012 - Corrections to comments only
 0E2                                ;
 0E2                                ; This file contains routines used to interface with the UART6 macros provided with KCPSM6
 0E2                                ; and was first supplied with a reference design called 'uart6_605' included in the
 0E2                                ; PicoBlaze package. The routines enable characters to be transmitted to and received
 0E2                                ; from the UART macros as well as perform a reset of the FIFO the buffers.
 0E2                                ;
 0E2                                ;     NOTE - This is not a standalone PSM file. The 'uart_control.psm' file supplied with
 0E2                                ;            the reference design stated above includes this file and calls the routines
 0E2                                ;            contained in this file.
 0E2                                ;
 0E2                                ;                INCLUDE "uart_interface_routines.psm"
 0E2                                ;
 0E2                                ;     Hint - The INCLUDE directive was introduced in KCPSM6 Assembler v2.00.
 0E2                                ;
 0E2                                ;
 0E2                                ; Whilst the reference design stated above was presented for the UART macros connected to
 0E2                                ; the USB/UART interface on the Xilinx ML605 Evaluation Kit this file can be ported to
 0E2                                ; any design for any board simply by setting the appropriate values in the CONSTANT
 0E2                                ; directives described below.
 0E2                                ;
 0E2                                ;
 0E2                                ;------------------------------------------------------------------------------------------
 0E2                                ; Hardware Constants
 0E2                                ;------------------------------------------------------------------------------------------
 0E2                                ;
 0E2                                ; The CONSTANT directives below define the input and output ports assigned to the UART
 0E2                                ; macros that implement a 115,200 baud rate communication with the USB/UART on the board.
 0E2                                ; Additional constants identify the allocation of signals to bits within a port.
 0E2                                ;
 0E2                                ;
 0E2                                ;
 0E2                                ; UART Status
 0E2                                ; -----------
 0E2                                ;
 0E2                                CONSTANT UART_status_port, 00                          ; Read status
 0E2                                CONSTANT UART_Tx_data_present, 00000001'b              ; Tx   data_present - bit0
 0E2                                CONSTANT UART_Tx_half_full, 00000010'b                 ;         half_full - bit1
 0E2                                CONSTANT UART_Tx_full, 00000100'b                      ;              full - bit2
 0E2                                CONSTANT UART_Rx_data_present, 00001000'b              ; Rx   data_present - bit3
 0E2                                CONSTANT UART_Rx_half_full, 00010000'b                 ;         half_full - bit4
 0E2                                CONSTANT UART_Rx_full, 00100000'b                      ;              full - bit5
 0E2                                ;
 0E2                                ; Write data to UART_TX6
 0E2                                ; ----------------------
 0E2                                ;
 0E2                                CONSTANT UART_TX6_output_port, 01
 0E2                                ;
 0E2                                ; Read data from UART_RX6
 0E2                                ; -----------------------
 0E2                                ;
 0E2                                CONSTANT UART_RX6_input_port, 01
 0E2                                ;
 0E2                                ; Reset UART buffers (Constant Optimised Port)
 0E2                                ; --------------------------------------------
 0E2                                ;
 0E2                                CONSTANT LCD_driver_send_port, 02
 0E2                                CONSTANT LCD_driver_en_port, 03
 0E2                                CONSTANT LCD_driver_ready_port, 04
 0E2                                CONSTANT LPC_data_port, 05
 0E2                                CONSTANT LPC_data_valid_port, 06
 0E2                                CONSTANT LPC_ready_port, 07
 0E2                                CONSTANT LPC_IN_data_port, 08                          ; from LPC
 0E2                                CONSTANT LPC_IN_data_valid_port, 09                    ; from LPC
 0E2                                CONSTANT LPC_IN_ready_port, 0A                         ; to LPC
 0E2                                CONSTANT IR_PORT, 0B
 0E2                                CONSTANT reset_UART_port, 01
 0E2                                CONSTANT UART_tx_reset, 00000001'b                     ; uart_tx6 reset - bit0
 0E2                                CONSTANT UART_rx_reset, 00000010'b                     ; uart_rx6 reset - bit1
 0E2                                CONSTANT UART_reset, 00000011'b                        ; reset Tx and Rx
 0E2                                CONSTANT UART_operate, 00000000'b                      ; Tx and Rx free to operate
 0E2                                CONSTANT LCD_en_reset, 00000000'b                      ; reset lcd en
 0E2                                CONSTANT LCD_en_syg, 00000001'b                        ; send lcd en
 0E2                                CONSTANT LCD_ready_syg, 00000001'b                     ; send lcd en
 0E2                                CONSTANT LCD_odebral_syg, 00000000'b
 0E2                                CONSTANT LPC_ready_syg, 00000001'b                     ; LPC ready to get data
 0E2                                CONSTANT LPC_data_valid_syg, 00000001'b                ; Pico data valid
 0E2                                CONSTANT LPC_dv_reset, 00000000'b                      ; reset Eth en
 0E2                                ;
 0E2                                ;
 0E2                                ;--------------------------------------------------------------------------------------
 0E2                                ; Routine to reset UART Buffers inside 'uart_tx6' and 'uart_rx6'
 0E2                                ;--------------------------------------------------------------------------------------
 0E2                                ;
 0E2                                ; This routine will generate and apply an active High reset pulse to  the FIFO
 0E2                                ; buffers in both the transmitter and receiver macros.
 0E2                                ;
 0E2                                ; Note that the reset signals have been assigned to a constant optimised output port
 0E2                                ; so the 'OUTPUTK' instructions are used and no registers contents are affected.
 0E2                                ;
 0E2                                ;
 0E2  2B031      reset_UART_macros: OUTPUTK 03[UART_reset], 1[reset_UART_port]
 0E3  2B001                         OUTPUTK 00[UART_operate], 1[reset_UART_port]
 0E4  25000                         RETURN 
 0E5  2B003    reset_lcd_en_status: OUTPUTK 00[LCD_en_reset], 3[LCD_driver_en_port]
 0E6  25000                         RETURN 
 0E7  2B006    reset_Eth_en_status: OUTPUTK 00[LPC_dv_reset], 6[LPC_data_valid_port]
 0E8  25000                         RETURN 
 0E9                                ;
 0E9                                ;
 0E9                                ;--------------------------------------------------------------------------------------
 0E9                                ; Routine to send one character to the UART Transmitter 'uart_tx6'
 0E9                                ;--------------------------------------------------------------------------------------
 0E9                                ;
 0E9                                ; This routine will transmit the character provided in register 's5'.
 0E9                                ;
 0E9                                ; Before the character is output to the 'UART_TX6' macro the status of the FIFO buffer
 0E9                                ; is checked to see if there is space. If the buffer is full then this routine will
 0E9                                ; wait for space to become available (e.g. the time required for a previous character
 0E9                                ; to be transmitted by the UART).
 0E9                                ;
 0E9                                ; Registers used s0 and s5 for the data (which is preserved)
 0E9                                ;
 0E9  09000                UART_TX: INPUT s0, 00[UART_status_port]                         ;Check if buffer is full
 0EA  0D004                         TEST s0, 04[UART_Tx_full]
 0EB  360E9                         JUMP NZ, 0E9[UART_TX]                                  ;wait if full
 0EC  2D501                         OUTPUT s5, 01[UART_TX6_output_port]
 0ED  25000                         RETURN 
 0EE                                ;--------------------------------------------------------------------------------------
 0EE                                ; Routine to wywsy³anie znaków do drivera lcd
 0EE                                ;--------------------------------------------------------------------------------------
 0EE  09004               LCD_send: INPUT s0, 04[LCD_driver_ready_port]                    ;Sprawdza czy driver mo¿e odbieraæ dane
 0EF  0D001                         TEST s0, 01[LCD_ready_syg]
 0F0  320EE                         JUMP Z, 0EE[LCD_send]                                  ;czeka a¿ bêdzie gotowy
 0F1  2DF02                         OUTPUT sF, 02[LCD_driver_send_port]
 0F2  2B013                         OUTPUTK 01[LCD_en_syg], 3[LCD_driver_en_port]
 0F3  09004        LCD_czy_odebral: INPUT s0, 04[LCD_driver_ready_port]                    ;Sprawdza czy driver odebra³ dane
 0F4  0D001                         TEST s0, 01[LCD_ready_syg]
 0F5  3A0F3                         JUMP C, 0F3[LCD_czy_odebral]
 0F6  2B003                         OUTPUTK 00[LCD_en_reset], 3[LCD_driver_en_port]
 0F7  25000                         RETURN 
 0F8                      LPC_send: ;CALL UART_TX
 0F8  09007                         INPUT s0, 07[LPC_ready_port]                           ;Sprawdza czy LPC mo¿e odbieraæ dane
 0F9  0D001                         TEST s0, 01[LPC_ready_syg]
 0FA                                ;INPUT s5, LPC_ready_port
 0FA                                ;CALL UART_TX
 0FA  320F8                         JUMP Z, 0F8[LPC_send]
 0FB  2DF05                         OUTPUT sF, 05[LPC_data_port]
 0FC  2B016                         OUTPUTK 01[LPC_data_valid_syg], 6[LPC_data_valid_port]
 0FD  09007        LPC_czy_odebral: INPUT s0, 07[LPC_ready_port]                           ;Sprawdza czy LPC odebra³ dane
 0FE  0D001                         TEST s0, 01[LPC_ready_syg]
 0FF  3A0FD                         JUMP C, 0FD[LPC_czy_odebral]
 100  2B006                         OUTPUTK 00[LPC_dv_reset], 6[LPC_data_valid_port]
 101  25000                         RETURN 
 102                         petla: 
 102  200E9                         CALL 0E9[UART_TX]
 103  22102                         JUMP 102[petla]
 104                                ;
 104                                ;
 104                                ;--------------------------------------------------------------------------------------
 104                                ; Routine to attempt to receive one character from the UART Receiver 'uart_rx6'
 104                                ;--------------------------------------------------------------------------------------
 104                                ;
 104                                ; This routine will attempt to receive one character from the 'UART_RX6' macro, and if
 104                                ; successful, will return that character in register 's5' and the Zero flag will be
 104                                ; reset (Z=0).
 104                                ;
 104                                ; If there are no characters available to be read from the FIFO buffer within the
 104                                ; 'UART_RX6' macro then this routine will timeout after ~2,000 clock cycles (which is
 104                                ; 40us at 50MHz) with the Zero flag set (Z=1). This timeout scheme ensures that KCPSM6
 104                                ; cannot become stuck in this routine if no characters are received. If you do want
 104                                ; KCPSM6 to wait indefinitely for a character to be received then either modify this
 104                                ; routine or perform a test of the Zero flag and repeat the call to this routine as
 104                                ; shown in this example...
 104                                ;
 104                                ;          wait_for_UART_RX: CALL UART_RX
 104                                ;                            JUMP Z, wait_for_UART_RX
 104                                ;
 104                                ;
 104                                ; Registers used s0, s1 and s5.
 104                                ;
 104  011A7                UART_RX: LOAD s1, A7[167'd]                                     ;Timeout = 167 x (6 instructions x 2 clock cycles)
 105  09000             rx_timeout: INPUT s0, 00[UART_status_port]
 106  0D008                         TEST s0, 08[UART_Rx_data_present]                      ;Z=0 and C=1 when data present
 107  3610B                         JUMP NZ, 10B[read_Rx]
 108  19101                         SUB s1, 01[1'd]
 109  31000                         RETURN Z                                               ;Timeout returns with Z=1 and C=0
 10A  22105                         JUMP 105[rx_timeout]
 10B                                ;
 10B  09501                read_Rx: INPUT s5, 01[UART_RX6_input_port]                      ;read character from buffer
 10C  25000                         RETURN 
 10D                                ;
 10D                                ;
 10D                                ;------------------------------------------------------------------------------------------
 10D                                ; End of 'uart_interface_routines.psm"'
 10D                                ;------------------------------------------------------------------------------------------
 10D                                ;
 10D                                INCLUDE "C:\studia\MGR\FPGA\mgr\PicoProgram\banners_conversts_send.psm"["banners_conversts_send.psm"]
 10D                                CONSTANT code_in_use, 03
 10D                                CONSTANT invalid_code, 07
 10D                                CONSTANT opening, 01
 10D                                CONSTANT no_money, 0F
 10D                                CONSTANT other_car, 02
 10D                                CONSTANT bad_format, 08
 10D                                CONSTANT internal_error, 05
 10D                                CONSTANT dont_let_him_go, 04
 10D                                CONSTANT button0, 3F
 10D                                CONSTANT button1, 3D
 10D                                CONSTANT button2, 3B
 10D                                CONSTANT button3, 39
 10D                                CONSTANT button4, 37
 10D                                CONSTANT button5, 35
 10D                                CONSTANT button6, 33
 10D                                CONSTANT button7, 31
 10D                                CONSTANT button8, 2F
 10D                                CONSTANT button9, 2D
 10D                                CONSTANT buttonON, 27
 10D                                CONSTANT buttonMute, 25
 10D                                CONSTANT buttonUp, 3F
 10D                                CONSTANT buttonDown, 3D
 10D                                CONSTANT buttonCenter, 09
 10D                                CONSTANT buttonLeft, 1D
 10D                                CONSTANT buttonRight, 1F
 10D                                CONSTANT driveIN, 29
 10D                                CONSTANT driveOUT, 2B
 10D  006C0           convert_send: LOAD s6, sC
 10E  1963F                         SUB s6, 3F[button0]
 10F  3A115                         JUMP C, 115[next_button1]
 110  0D6FF                         TEST s6, FF[11111111'b]
 111  36115                         JUMP NZ, 115[next_button1]
 112  01F30                         LOAD sF, 30["0"]
 113  2003C                         CALL 03C[LPC_LCD_send]
 114  25000                         RETURN 
 115  006C0           next_button1: LOAD s6, sC
 116  1963D                         SUB s6, 3D[button1]
 117  3A11D                         JUMP C, 11D[next_button2]
 118  0D6FF                         TEST s6, FF[11111111'b]
 119  3611D                         JUMP NZ, 11D[next_button2]
 11A  01F31                         LOAD sF, 31["1"]
 11B  2003C                         CALL 03C[LPC_LCD_send]
 11C  25000                         RETURN 
 11D  006C0           next_button2: LOAD s6, sC
 11E  1963B                         SUB s6, 3B[button2]
 11F  3A125                         JUMP C, 125[next_button3]
 120  0D6FF                         TEST s6, FF[11111111'b]
 121  36125                         JUMP NZ, 125[next_button3]
 122  01F32                         LOAD sF, 32["2"]
 123  2003C                         CALL 03C[LPC_LCD_send]
 124  25000                         RETURN 
 125  006C0           next_button3: LOAD s6, sC
 126  19639                         SUB s6, 39[button3]
 127  3A12D                         JUMP C, 12D[next_button4]
 128  0D6FF                         TEST s6, FF[11111111'b]
 129  3612D                         JUMP NZ, 12D[next_button4]
 12A  01F33                         LOAD sF, 33["3"]
 12B  2003C                         CALL 03C[LPC_LCD_send]
 12C  25000                         RETURN 
 12D  006C0           next_button4: LOAD s6, sC
 12E  19637                         SUB s6, 37[button4]
 12F  3A135                         JUMP C, 135[next_button5]
 130  0D6FF                         TEST s6, FF[11111111'b]
 131  36135                         JUMP NZ, 135[next_button5]
 132  01F34                         LOAD sF, 34["4"]
 133  2003C                         CALL 03C[LPC_LCD_send]
 134  25000                         RETURN 
 135  006C0           next_button5: LOAD s6, sC
 136  19635                         SUB s6, 35[button5]
 137  3A13D                         JUMP C, 13D[next_button6]
 138  0D6FF                         TEST s6, FF[11111111'b]
 139  3613D                         JUMP NZ, 13D[next_button6]
 13A  01F35                         LOAD sF, 35["5"]
 13B  2003C                         CALL 03C[LPC_LCD_send]
 13C  25000                         RETURN 
 13D  006C0           next_button6: LOAD s6, sC
 13E  19633                         SUB s6, 33[button6]
 13F  3A145                         JUMP C, 145[next_button7]
 140  0D6FF                         TEST s6, FF[11111111'b]
 141  36145                         JUMP NZ, 145[next_button7]
 142  01F36                         LOAD sF, 36["6"]
 143  2003C                         CALL 03C[LPC_LCD_send]
 144  25000                         RETURN 
 145  006C0           next_button7: LOAD s6, sC
 146  19631                         SUB s6, 31[button7]
 147  3A14D                         JUMP C, 14D[next_button8]
 148  0D6FF                         TEST s6, FF[11111111'b]
 149  3614D                         JUMP NZ, 14D[next_button8]
 14A  01F37                         LOAD sF, 37["7"]
 14B  2003C                         CALL 03C[LPC_LCD_send]
 14C  25000                         RETURN 
 14D  006C0           next_button8: LOAD s6, sC
 14E  1962F                         SUB s6, 2F[button8]
 14F  3A155                         JUMP C, 155[next_button9]
 150  0D6FF                         TEST s6, FF[11111111'b]
 151  36155                         JUMP NZ, 155[next_button9]
 152  01F38                         LOAD sF, 38["8"]
 153  2003C                         CALL 03C[LPC_LCD_send]
 154  25000                         RETURN 
 155  006C0           next_button9: LOAD s6, sC
 156  1962D                         SUB s6, 2D[button9]
 157  3A15D                         JUMP C, 15D[next_button10]
 158  0D6FF                         TEST s6, FF[11111111'b]
 159  3615D                         JUMP NZ, 15D[next_button10]
 15A  01F39                         LOAD sF, 39["9"]
 15B  2003C                         CALL 03C[LPC_LCD_send]
 15C  25000                         RETURN 
 15D  006C0          next_button10: LOAD s6, sC
 15E  19629                         SUB s6, 29[driveIN]
 15F  3A165                         JUMP C, 165[next_button11]
 160  0D6FF                         TEST s6, FF[11111111'b]
 161  36165                         JUMP NZ, 165[next_button11]
 162  00FC0                         LOAD sF, sC
 163  2003C                         CALL 03C[LPC_LCD_send]
 164  25000                         RETURN 
 165  006C0          next_button11: LOAD s6, sC
 166  1962B                         SUB s6, 2B[driveOUT]
 167  3A1BA                         JUMP C, 1BA[just_return]
 168  0D6FF                         TEST s6, FF[11111111'b]
 169  361BA                         JUMP NZ, 1BA[just_return]
 16A  00FC0                         LOAD sF, sC
 16B  2003C                         CALL 03C[LPC_LCD_send]
 16C  25000                         RETURN 
 16D  00650           which_banner: LOAD s6, s5
 16E  19603                         SUB s6, 03[code_in_use]
 16F  3A176                         JUMP C, 176[next_banner1]
 170  0D6FF                         TEST s6, FF[11111111'b]
 171  36176                         JUMP NZ, 176[next_banner1]
 172  01F1B                         LOAD sF, 1B[ESC]
 173  200EE                         CALL 0EE[LCD_send]
 174  201C2                         CALL 1C2[banner_message]
 175  25000                         RETURN 
 176  00650           next_banner1: LOAD s6, s5
 177  19601                         SUB s6, 01[opening]
 178  3A184                         JUMP C, 184[next_banner2]
 179  0D6FF                         TEST s6, FF[11111111'b]
 17A  36184                         JUMP NZ, 184[next_banner2]
 17B  01F1B                         LOAD sF, 1B[ESC]
 17C  200EE                         CALL 0EE[LCD_send]
 17D  201D6                         CALL 1D6[banner2_message]
 17E  0900B  IR_czekaj_na_przejazd: INPUT s0, 0B[IR_PORT]
 17F  0D001                         TEST s0, 01[00000001'b]
 180  3A17E                         JUMP C, 17E[IR_czekaj_na_przejazd]
 181  01F44                         LOAD sF, 44["D"]
 182  200F8                         CALL 0F8[LPC_send]
 183  25000                         RETURN 
 184  00650           next_banner2: LOAD s6, s5
 185  19607                         SUB s6, 07[invalid_code]
 186  3A18D                         JUMP C, 18D[next_banner3]
 187  0D6FF                         TEST s6, FF[11111111'b]
 188  3618D                         JUMP NZ, 18D[next_banner3]
 189  01F1B                         LOAD sF, 1B[ESC]
 18A  200EE                         CALL 0EE[LCD_send]
 18B  201FA                         CALL 1FA[banner3_message]
 18C  25000                         RETURN 
 18D  00650           next_banner3: LOAD s6, s5
 18E  1960F                         SUB s6, 0F[no_money]
 18F  3A196                         JUMP C, 196[next_banner4]
 190  0D6FF                         TEST s6, FF[11111111'b]
 191  36196                         JUMP NZ, 196[next_banner4]
 192  01F1B                         LOAD sF, 1B[ESC]
 193  200EE                         CALL 0EE[LCD_send]
 194  20210                         CALL 210[banner4_message]
 195  25000                         RETURN 
 196  00650           next_banner4: LOAD s6, s5
 197  19602                         SUB s6, 02[other_car]
 198  3A19F                         JUMP C, 19F[next_banner5]
 199  0D6FF                         TEST s6, FF[11111111'b]
 19A  3619F                         JUMP NZ, 19F[next_banner5]
 19B  01F1B                         LOAD sF, 1B[ESC]
 19C  200EE                         CALL 0EE[LCD_send]
 19D  20234                         CALL 234[banner5_message]
 19E  25000                         RETURN 
 19F  00650           next_banner5: LOAD s6, s5
 1A0  19608                         SUB s6, 08[bad_format]
 1A1  3A1A8                         JUMP C, 1A8[next_banner6]
 1A2  0D6FF                         TEST s6, FF[11111111'b]
 1A3  361A8                         JUMP NZ, 1A8[next_banner6]
 1A4  01F1B                         LOAD sF, 1B[ESC]
 1A5  200EE                         CALL 0EE[LCD_send]
 1A6  20256                         CALL 256[banner6_message]
 1A7  25000                         RETURN 
 1A8  00650           next_banner6: LOAD s6, s5
 1A9  19605                         SUB s6, 05[internal_error]
 1AA  3A1B1                         JUMP C, 1B1[next_banner7]
 1AB  0D6FF                         TEST s6, FF[11111111'b]
 1AC  361B1                         JUMP NZ, 1B1[next_banner7]
 1AD  01F1B                         LOAD sF, 1B[ESC]
 1AE  200EE                         CALL 0EE[LCD_send]
 1AF  20279                         CALL 279[banner7_message]
 1B0  25000                         RETURN 
 1B1  00650           next_banner7: LOAD s6, s5
 1B2  19604                         SUB s6, 04[dont_let_him_go]
 1B3  3A1BA                         JUMP C, 1BA[just_return]
 1B4  0D6FF                         TEST s6, FF[11111111'b]
 1B5  361BA                         JUMP NZ, 1BA[just_return]
 1B6  01F1B                         LOAD sF, 1B[ESC]
 1B7  200EE                         CALL 0EE[LCD_send]
 1B8  2029C                         CALL 29C[banner8_message]
 1B9  25000                         RETURN 
 1BA  25000            just_return: RETURN 
 1BB                                ;
 1BB                                ;------------------------------------------------------------------------------------------
 1BB                                ; Send a message to the UART
 1BB                                ;------------------------------------------------------------------------------------------
 1BB                                ;
 1BB                                ; A message is transmitted to the USB-UART.
 1BB                                ; The start address of the message must be provided in [sB,sA].
 1BB                                ; Terminate the transmission with a NULL character (00 hex).
 1BB                                ;
 1BB  24BA0           send_message: CALL@ (sB, sA)
 1BC  1D500                         COMPARE s5, 00                                         ;terminate on NUL character
 1BD  31000                         RETURN Z
 1BE  200E9                         CALL 0E9[UART_TX]
 1BF  11A01                         ADD sA, 01[1'd]
 1C0  13B00                         ADDCY sB, 00[0'd]
 1C1  221BB                         JUMP 1BB[send_message]
 1C2                                ;
 1C2                                ;
 1C2                                ;------------------------------------------------------------------------------------------
 1C2                                ; Send Carriage Return to UART
 1C2                                ;------------------------------------------------------------------------------------------
 1C2                                ;
 1C2                                ; Registers used s0, s1, s2, and s5.
 1C2                                ;
 1C2  01B01         banner_message: LOAD sB, 01[banner_msg'upper]
 1C3  01AC7                         LOAD sA, C7[banner_msg'lower]
 1C4  202D5                         CALL 2D5[send_banner]
 1C5  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1C6  25000                         RETURN 
 1C7                                ;
 1C7                                STRING bannert$, "  Kod w uzyciu"
 1C7                                ;
 1C7                                ;
 1C7  21F20             banner_msg: LOAD&RETURN sF, 20[bannert$:" "]
 1C8  21F20                         LOAD&RETURN sF, 20[bannert$:" "]
 1C9  21F4B                         LOAD&RETURN sF, 4B[bannert$:"K"]
 1CA  21F6F                         LOAD&RETURN sF, 6F[bannert$:"o"]
 1CB  21F64                         LOAD&RETURN sF, 64[bannert$:"d"]
 1CC  21F20                         LOAD&RETURN sF, 20[bannert$:" "]
 1CD  21F77                         LOAD&RETURN sF, 77[bannert$:"w"]
 1CE  21F20                         LOAD&RETURN sF, 20[bannert$:" "]
 1CF  21F75                         LOAD&RETURN sF, 75[bannert$:"u"]
 1D0  21F7A                         LOAD&RETURN sF, 7A[bannert$:"z"]
 1D1  21F79                         LOAD&RETURN sF, 79[bannert$:"y"]
 1D2  21F63                         LOAD&RETURN sF, 63[bannert$:"c"]
 1D3  21F69                         LOAD&RETURN sF, 69[bannert$:"i"]
 1D4  21F75                         LOAD&RETURN sF, 75[bannert$:"u"]
 1D5  21F00                         LOAD&RETURN sF, 00[NUL]
 1D6                                ;
 1D6                                ;
 1D6                                ;
 1D6  01B01        banner2_message: LOAD sB, 01[banner2_msg'upper]
 1D7  01ADB                         LOAD sA, DB[banner2_msg'lower]
 1D8  202D5                         CALL 2D5[send_banner]
 1D9  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1DA  25000                         RETURN 
 1DB                                ;
 1DB                                STRING bannert2$, "     Prosze        przejezdzac"
 1DB                                ;
 1DB                                ;
 1DB  21F20            banner2_msg: LOAD&RETURN sF, 20[bannert2$:" "]
 1DC  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1DD  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1DE  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1DF  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1E0  21F50                         LOAD&RETURN sF, 50[bannert2$:"P"]
 1E1  21F72                         LOAD&RETURN sF, 72[bannert2$:"r"]
 1E2  21F6F                         LOAD&RETURN sF, 6F[bannert2$:"o"]
 1E3  21F73                         LOAD&RETURN sF, 73[bannert2$:"s"]
 1E4  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1E5  21F65                         LOAD&RETURN sF, 65[bannert2$:"e"]
 1E6  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1E7  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1E8  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1E9  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1EA  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1EB  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1EC  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1ED  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1EE  21F70                         LOAD&RETURN sF, 70[bannert2$:"p"]
 1EF  21F72                         LOAD&RETURN sF, 72[bannert2$:"r"]
 1F0  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1F1  21F65                         LOAD&RETURN sF, 65[bannert2$:"e"]
 1F2  21F6A                         LOAD&RETURN sF, 6A[bannert2$:"j"]
 1F3  21F65                         LOAD&RETURN sF, 65[bannert2$:"e"]
 1F4  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1F5  21F64                         LOAD&RETURN sF, 64[bannert2$:"d"]
 1F6  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1F7  21F61                         LOAD&RETURN sF, 61[bannert2$:"a"]
 1F8  21F63                         LOAD&RETURN sF, 63[bannert2$:"c"]
 1F9  21F00                         LOAD&RETURN sF, 00[NUL]
 1FA  01B01        banner3_message: LOAD sB, 01[banner3_msg'upper]
 1FB  01AFF                         LOAD sA, FF[banner3_msg'lower]
 1FC  202D5                         CALL 2D5[send_banner]
 1FD  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1FE  25000                         RETURN 
 1FF                                ;
 1FF                                STRING bannert3$, " Niewazny  kod  "
 1FF                                ;
 1FF                                ;
 1FF  21F20            banner3_msg: LOAD&RETURN sF, 20[bannert3$:" "]
 200  21F4E                         LOAD&RETURN sF, 4E[bannert3$:"N"]
 201  21F69                         LOAD&RETURN sF, 69[bannert3$:"i"]
 202  21F65                         LOAD&RETURN sF, 65[bannert3$:"e"]
 203  21F77                         LOAD&RETURN sF, 77[bannert3$:"w"]
 204  21F61                         LOAD&RETURN sF, 61[bannert3$:"a"]
 205  21F7A                         LOAD&RETURN sF, 7A[bannert3$:"z"]
 206  21F6E                         LOAD&RETURN sF, 6E[bannert3$:"n"]
 207  21F79                         LOAD&RETURN sF, 79[bannert3$:"y"]
 208  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 209  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 20A  21F6B                         LOAD&RETURN sF, 6B[bannert3$:"k"]
 20B  21F6F                         LOAD&RETURN sF, 6F[bannert3$:"o"]
 20C  21F64                         LOAD&RETURN sF, 64[bannert3$:"d"]
 20D  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 20E  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 20F  21F00                         LOAD&RETURN sF, 00[NUL]
 210  01B02        banner4_message: LOAD sB, 02[banner4_msg'upper]
 211  01A15                         LOAD sA, 15[banner4_msg'lower]
 212  202D5                         CALL 2D5[send_banner]
 213  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 214  25000                         RETURN 
 215                                ;
 215                                STRING bannert4$, "Twoj abonament  nie jest wazny"
 215                                ;
 215                                ;
 215  21F54            banner4_msg: LOAD&RETURN sF, 54[bannert4$:"T"]
 216  21F77                         LOAD&RETURN sF, 77[bannert4$:"w"]
 217  21F6F                         LOAD&RETURN sF, 6F[bannert4$:"o"]
 218  21F6A                         LOAD&RETURN sF, 6A[bannert4$:"j"]
 219  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 21A  21F61                         LOAD&RETURN sF, 61[bannert4$:"a"]
 21B  21F62                         LOAD&RETURN sF, 62[bannert4$:"b"]
 21C  21F6F                         LOAD&RETURN sF, 6F[bannert4$:"o"]
 21D  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 21E  21F61                         LOAD&RETURN sF, 61[bannert4$:"a"]
 21F  21F6D                         LOAD&RETURN sF, 6D[bannert4$:"m"]
 220  21F65                         LOAD&RETURN sF, 65[bannert4$:"e"]
 221  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 222  21F74                         LOAD&RETURN sF, 74[bannert4$:"t"]
 223  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 224  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 225  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 226  21F69                         LOAD&RETURN sF, 69[bannert4$:"i"]
 227  21F65                         LOAD&RETURN sF, 65[bannert4$:"e"]
 228  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 229  21F6A                         LOAD&RETURN sF, 6A[bannert4$:"j"]
 22A  21F65                         LOAD&RETURN sF, 65[bannert4$:"e"]
 22B  21F73                         LOAD&RETURN sF, 73[bannert4$:"s"]
 22C  21F74                         LOAD&RETURN sF, 74[bannert4$:"t"]
 22D  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 22E  21F77                         LOAD&RETURN sF, 77[bannert4$:"w"]
 22F  21F61                         LOAD&RETURN sF, 61[bannert4$:"a"]
 230  21F7A                         LOAD&RETURN sF, 7A[bannert4$:"z"]
 231  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 232  21F79                         LOAD&RETURN sF, 79[bannert4$:"y"]
 233  21F00                         LOAD&RETURN sF, 00[NUL]
 234                                ;
 234  01B02        banner5_message: LOAD sB, 02[banner5_msg'upper]
 235  01A39                         LOAD sA, 39[banner5_msg'lower]
 236  202D5                         CALL 2D5[send_banner]
 237  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 238  25000                         RETURN 
 239                                ;
 239                                STRING bannert5$, "Inne Twoje auto juz wjechalo"
 239                                ;
 239                                ;
 239  21F49            banner5_msg: LOAD&RETURN sF, 49[bannert5$:"I"]
 23A  21F6E                         LOAD&RETURN sF, 6E[bannert5$:"n"]
 23B  21F6E                         LOAD&RETURN sF, 6E[bannert5$:"n"]
 23C  21F65                         LOAD&RETURN sF, 65[bannert5$:"e"]
 23D  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 23E  21F54                         LOAD&RETURN sF, 54[bannert5$:"T"]
 23F  21F77                         LOAD&RETURN sF, 77[bannert5$:"w"]
 240  21F6F                         LOAD&RETURN sF, 6F[bannert5$:"o"]
 241  21F6A                         LOAD&RETURN sF, 6A[bannert5$:"j"]
 242  21F65                         LOAD&RETURN sF, 65[bannert5$:"e"]
 243  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 244  21F61                         LOAD&RETURN sF, 61[bannert5$:"a"]
 245  21F75                         LOAD&RETURN sF, 75[bannert5$:"u"]
 246  21F74                         LOAD&RETURN sF, 74[bannert5$:"t"]
 247  21F6F                         LOAD&RETURN sF, 6F[bannert5$:"o"]
 248  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 249  21F6A                         LOAD&RETURN sF, 6A[bannert5$:"j"]
 24A  21F75                         LOAD&RETURN sF, 75[bannert5$:"u"]
 24B  21F7A                         LOAD&RETURN sF, 7A[bannert5$:"z"]
 24C  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 24D  21F77                         LOAD&RETURN sF, 77[bannert5$:"w"]
 24E  21F6A                         LOAD&RETURN sF, 6A[bannert5$:"j"]
 24F  21F65                         LOAD&RETURN sF, 65[bannert5$:"e"]
 250  21F63                         LOAD&RETURN sF, 63[bannert5$:"c"]
 251  21F68                         LOAD&RETURN sF, 68[bannert5$:"h"]
 252  21F61                         LOAD&RETURN sF, 61[bannert5$:"a"]
 253  21F6C                         LOAD&RETURN sF, 6C[bannert5$:"l"]
 254  21F6F                         LOAD&RETURN sF, 6F[bannert5$:"o"]
 255  21F00                         LOAD&RETURN sF, 00[NUL]
 256                                ;
 256                                ;
 256                                ;
 256  01B02        banner6_message: LOAD sB, 02[banner6_msg'upper]
 257  01A5B                         LOAD sA, 5B[banner6_msg'lower]
 258  202D5                         CALL 2D5[send_banner]
 259  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 25A  25000                         RETURN 
 25B                                ;
 25B                                STRING bannert6$, "  Niepoprawny     format kodu"
 25B                                ;
 25B                                ;
 25B  21F20            banner6_msg: LOAD&RETURN sF, 20[bannert6$:" "]
 25C  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 25D  21F4E                         LOAD&RETURN sF, 4E[bannert6$:"N"]
 25E  21F69                         LOAD&RETURN sF, 69[bannert6$:"i"]
 25F  21F65                         LOAD&RETURN sF, 65[bannert6$:"e"]
 260  21F70                         LOAD&RETURN sF, 70[bannert6$:"p"]
 261  21F6F                         LOAD&RETURN sF, 6F[bannert6$:"o"]
 262  21F70                         LOAD&RETURN sF, 70[bannert6$:"p"]
 263  21F72                         LOAD&RETURN sF, 72[bannert6$:"r"]
 264  21F61                         LOAD&RETURN sF, 61[bannert6$:"a"]
 265  21F77                         LOAD&RETURN sF, 77[bannert6$:"w"]
 266  21F6E                         LOAD&RETURN sF, 6E[bannert6$:"n"]
 267  21F79                         LOAD&RETURN sF, 79[bannert6$:"y"]
 268  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 269  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 26A  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 26B  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 26C  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 26D  21F66                         LOAD&RETURN sF, 66[bannert6$:"f"]
 26E  21F6F                         LOAD&RETURN sF, 6F[bannert6$:"o"]
 26F  21F72                         LOAD&RETURN sF, 72[bannert6$:"r"]
 270  21F6D                         LOAD&RETURN sF, 6D[bannert6$:"m"]
 271  21F61                         LOAD&RETURN sF, 61[bannert6$:"a"]
 272  21F74                         LOAD&RETURN sF, 74[bannert6$:"t"]
 273  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 274  21F6B                         LOAD&RETURN sF, 6B[bannert6$:"k"]
 275  21F6F                         LOAD&RETURN sF, 6F[bannert6$:"o"]
 276  21F64                         LOAD&RETURN sF, 64[bannert6$:"d"]
 277  21F75                         LOAD&RETURN sF, 75[bannert6$:"u"]
 278  21F00                         LOAD&RETURN sF, 00[NUL]
 279                                ;
 279                                ;
 279                                ;
 279  01B02        banner7_message: LOAD sB, 02[banner7_msg'upper]
 27A  01A7E                         LOAD sA, 7E[banner7_msg'lower]
 27B  202D5                         CALL 2D5[send_banner]
 27C  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 27D  25000                         RETURN 
 27E                                ;
 27E                                STRING bannert7$, "Blad wewnetrzny  Przepraszamy"
 27E                                ;
 27E                                ;
 27E  21F42            banner7_msg: LOAD&RETURN sF, 42[bannert7$:"B"]
 27F  21F6C                         LOAD&RETURN sF, 6C[bannert7$:"l"]
 280  21F61                         LOAD&RETURN sF, 61[bannert7$:"a"]
 281  21F64                         LOAD&RETURN sF, 64[bannert7$:"d"]
 282  21F20                         LOAD&RETURN sF, 20[bannert7$:" "]
 283  21F77                         LOAD&RETURN sF, 77[bannert7$:"w"]
 284  21F65                         LOAD&RETURN sF, 65[bannert7$:"e"]
 285  21F77                         LOAD&RETURN sF, 77[bannert7$:"w"]
 286  21F6E                         LOAD&RETURN sF, 6E[bannert7$:"n"]
 287  21F65                         LOAD&RETURN sF, 65[bannert7$:"e"]
 288  21F74                         LOAD&RETURN sF, 74[bannert7$:"t"]
 289  21F72                         LOAD&RETURN sF, 72[bannert7$:"r"]
 28A  21F7A                         LOAD&RETURN sF, 7A[bannert7$:"z"]
 28B  21F6E                         LOAD&RETURN sF, 6E[bannert7$:"n"]
 28C  21F79                         LOAD&RETURN sF, 79[bannert7$:"y"]
 28D  21F20                         LOAD&RETURN sF, 20[bannert7$:" "]
 28E  21F20                         LOAD&RETURN sF, 20[bannert7$:" "]
 28F  21F50                         LOAD&RETURN sF, 50[bannert7$:"P"]
 290  21F72                         LOAD&RETURN sF, 72[bannert7$:"r"]
 291  21F7A                         LOAD&RETURN sF, 7A[bannert7$:"z"]
 292  21F65                         LOAD&RETURN sF, 65[bannert7$:"e"]
 293  21F70                         LOAD&RETURN sF, 70[bannert7$:"p"]
 294  21F72                         LOAD&RETURN sF, 72[bannert7$:"r"]
 295  21F61                         LOAD&RETURN sF, 61[bannert7$:"a"]
 296  21F73                         LOAD&RETURN sF, 73[bannert7$:"s"]
 297  21F7A                         LOAD&RETURN sF, 7A[bannert7$:"z"]
 298  21F61                         LOAD&RETURN sF, 61[bannert7$:"a"]
 299  21F6D                         LOAD&RETURN sF, 6D[bannert7$:"m"]
 29A  21F79                         LOAD&RETURN sF, 79[bannert7$:"y"]
 29B  21F00                         LOAD&RETURN sF, 00[NUL]
 29C                                ;
 29C                                ;
 29C                                ;
 29C  01B02        banner8_message: LOAD sB, 02[banner8_msg'upper]
 29D  01AA1                         LOAD sA, A1[banner8_msg'lower]
 29E  202D5                         CALL 2D5[send_banner]
 29F  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 2A0  25000                         RETURN 
 2A1                                ;
 2A1                                STRING bannert8$, "     Zakaz          wyjazdu"
 2A1                                ;
 2A1                                ;
 2A1  21F20            banner8_msg: LOAD&RETURN sF, 20[bannert8$:" "]
 2A2  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2A3  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2A4  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2A5  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2A6  21F5A                         LOAD&RETURN sF, 5A[bannert8$:"Z"]
 2A7  21F61                         LOAD&RETURN sF, 61[bannert8$:"a"]
 2A8  21F6B                         LOAD&RETURN sF, 6B[bannert8$:"k"]
 2A9  21F61                         LOAD&RETURN sF, 61[bannert8$:"a"]
 2AA  21F7A                         LOAD&RETURN sF, 7A[bannert8$:"z"]
 2AB  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2AC  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2AD  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2AE  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2AF  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2B0  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2B1  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2B2  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2B3  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2B4  21F20                         LOAD&RETURN sF, 20[bannert8$:" "]
 2B5  21F77                         LOAD&RETURN sF, 77[bannert8$:"w"]
 2B6  21F79                         LOAD&RETURN sF, 79[bannert8$:"y"]
 2B7  21F6A                         LOAD&RETURN sF, 6A[bannert8$:"j"]
 2B8  21F61                         LOAD&RETURN sF, 61[bannert8$:"a"]
 2B9  21F7A                         LOAD&RETURN sF, 7A[bannert8$:"z"]
 2BA  21F64                         LOAD&RETURN sF, 64[bannert8$:"d"]
 2BB  21F75                         LOAD&RETURN sF, 75[bannert8$:"u"]
 2BC  21F00                         LOAD&RETURN sF, 00[NUL]
 2BD                                ;
 2BD                                ;
 2BD                                ;
 2BD  01B02             ini_banner: LOAD sB, 02[ini_banner_lr'upper]
 2BE  01AC2                         LOAD sA, C2[ini_banner_lr'lower]
 2BF  202D5                         CALL 2D5[send_banner]
 2C0  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 2C1  25000                         RETURN 
 2C2                                ;
 2C2                                STRING ini_banner_msg$, "Podaj kod wjazdu>>"
 2C2                                ;
 2C2                                ;
 2C2  21F50          ini_banner_lr: LOAD&RETURN sF, 50[ini_banner_msg$:"P"]
 2C3  21F6F                         LOAD&RETURN sF, 6F[ini_banner_msg$:"o"]
 2C4  21F64                         LOAD&RETURN sF, 64[ini_banner_msg$:"d"]
 2C5  21F61                         LOAD&RETURN sF, 61[ini_banner_msg$:"a"]
 2C6  21F6A                         LOAD&RETURN sF, 6A[ini_banner_msg$:"j"]
 2C7  21F20                         LOAD&RETURN sF, 20[ini_banner_msg$:" "]
 2C8  21F6B                         LOAD&RETURN sF, 6B[ini_banner_msg$:"k"]
 2C9  21F6F                         LOAD&RETURN sF, 6F[ini_banner_msg$:"o"]
 2CA  21F64                         LOAD&RETURN sF, 64[ini_banner_msg$:"d"]
 2CB  21F20                         LOAD&RETURN sF, 20[ini_banner_msg$:" "]
 2CC  21F77                         LOAD&RETURN sF, 77[ini_banner_msg$:"w"]
 2CD  21F6A                         LOAD&RETURN sF, 6A[ini_banner_msg$:"j"]
 2CE  21F61                         LOAD&RETURN sF, 61[ini_banner_msg$:"a"]
 2CF  21F7A                         LOAD&RETURN sF, 7A[ini_banner_msg$:"z"]
 2D0  21F64                         LOAD&RETURN sF, 64[ini_banner_msg$:"d"]
 2D1  21F75                         LOAD&RETURN sF, 75[ini_banner_msg$:"u"]
 2D2  21F3E                         LOAD&RETURN sF, 3E[ini_banner_msg$:">"]
 2D3  21F3E                         LOAD&RETURN sF, 3E[ini_banner_msg$:">"]
 2D4  21F00                         LOAD&RETURN sF, 00[NUL]
 2D5                                ;
 2D5                                ;
 2D5                                ;
 2D5                                ; Send a banner to LCD
 2D5                                ;------------------------------------------------------------------------------------------
 2D5                                ;
 2D5                                ; A message is transmitted to the USB-UART.
 2D5                                ; The start address of the message must be provided in [sB,sA].
 2D5                                ; Terminate the transmission with a NULL character (00 hex).
 2D5                                ;
 2D5  24BA0            send_banner: CALL@ (sB, sA)
 2D6  1DF00                         COMPARE sF, 00                                         ;terminate on NUL character
 2D7  31000                         RETURN Z
 2D8                                ;LOAD sF,s5
 2D8  200EE                         CALL 0EE[LCD_send]
 2D9  11A01                         ADD sA, 01[1'd]
 2DA  13B00                         ADDCY sB, 00[0'd]
 2DB  222D5                         JUMP 2D5[send_banner]
 2DC                                ;
 2DC                                ;
 2DC                                ;------------------------------------------------------------------------------------------
 2DC                                ; End of Program
 2DC                                ;------------------------------------------------------------------------------------------
 2DC                                ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\studia\MGR\FPGA\mgr\PicoProgram\program.psm
C:\studia\MGR\FPGA\mgr\PicoProgram\communication_routines.psm
C:\studia\MGR\FPGA\mgr\PicoProgram\banners_conversts_send.psm



List of defined constants

 CONSTANT name          Value        Source PSM File

 timestamp_hours        19'd         
 timestamp_minutes      10'd         
 timestamp_seconds      07'd         
 datestamp_year         15'd         
 datestamp_month        12'd         
 datestamp_day          06'd         
 NUL                    00           
 BEL                    07           
 BS                     08           
 HT                     09           
 LF                     0A           
 VT                     0B           
 CR                     0D           
 ESC                    1B           
 DEL                    7F           
 DCS                    90           
 ST                     9C           
 hex_value0             00           program.psm
 hex_value1             01           program.psm
 decimal0               02           program.psm
 decimal1               03           program.psm
 decimal2               04           program.psm
 decimal3               05           program.psm
 decimal4               06           program.psm
 UART_status_port       00           communication_routines.psm
 UART_Tx_data_present   00000001'b   communication_routines.psm
 UART_Tx_half_full      00000010'b   communication_routines.psm
 UART_Tx_full           00000100'b   communication_routines.psm
 UART_Rx_data_present   00001000'b   communication_routines.psm
 UART_Rx_half_full      00010000'b   communication_routines.psm
 UART_Rx_full           00100000'b   communication_routines.psm
 UART_TX6_output_port   01           communication_routines.psm
 UART_RX6_input_port    01           communication_routines.psm
 LCD_driver_send_port   02           communication_routines.psm
 LCD_driver_en_port     03           communication_routines.psm
 LCD_driver_ready_port  04           communication_routines.psm
 LPC_data_port          05           communication_routines.psm
 LPC_data_valid_port    06           communication_routines.psm
 LPC_ready_port         07           communication_routines.psm
 LPC_IN_data_port       08           communication_routines.psm
 LPC_IN_data_valid_port 09           communication_routines.psm
 LPC_IN_ready_port      0A           communication_routines.psm
 IR_PORT                0B           communication_routines.psm
 reset_UART_port        01           communication_routines.psm
 UART_tx_reset          00000001'b   communication_routines.psm
 UART_rx_reset          00000010'b   communication_routines.psm
 UART_reset             00000011'b   communication_routines.psm
 UART_operate           00000000'b   communication_routines.psm
 LCD_en_reset           00000000'b   communication_routines.psm
 LCD_en_syg             00000001'b   communication_routines.psm
 LCD_ready_syg          00000001'b   communication_routines.psm
 LCD_odebral_syg        00000000'b   communication_routines.psm
 LPC_ready_syg          00000001'b   communication_routines.psm
 LPC_data_valid_syg     00000001'b   communication_routines.psm
 LPC_dv_reset           00000000'b   communication_routines.psm
 code_in_use            03           banners_conversts_send.psm
 invalid_code           07           banners_conversts_send.psm
 opening                01           banners_conversts_send.psm
 no_money               0F           banners_conversts_send.psm
 other_car              02           banners_conversts_send.psm
 bad_format             08           banners_conversts_send.psm
 internal_error         05           banners_conversts_send.psm
 dont_let_him_go        04           banners_conversts_send.psm
 button0                3F           banners_conversts_send.psm
 button1                3D           banners_conversts_send.psm
 button2                3B           banners_conversts_send.psm
 button3                39           banners_conversts_send.psm
 button4                37           banners_conversts_send.psm
 button5                35           banners_conversts_send.psm
 button6                33           banners_conversts_send.psm
 button7                31           banners_conversts_send.psm
 button8                2F           banners_conversts_send.psm
 button9                2D           banners_conversts_send.psm
 buttonON               27           banners_conversts_send.psm
 buttonMute             25           banners_conversts_send.psm
 buttonUp               3F           banners_conversts_send.psm
 buttonDown             3D           banners_conversts_send.psm
 buttonCenter           09           banners_conversts_send.psm
 buttonLeft             1D           banners_conversts_send.psm
 buttonRight            1F           banners_conversts_send.psm
 driveIN                29           banners_conversts_send.psm
 driveOUT               2B           banners_conversts_send.psm



No TABLEs defined



List of text strings

 STRING name       String                            Source PSM File

 KCPSM6_version$   "v2.70"                           
 datestamp$        "06 Dec 2015"                     
 timestamp$        "19:10:07"                        
 bannert$          "  Kod w uzyciu"                  banners_conversts_send.psm
 bannert2$         "     Prosze        przejezdzac"  banners_conversts_send.psm
 bannert3$         " Niewazny  kod  "                banners_conversts_send.psm
 bannert4$         "Twoj abonament  nie jest wazny"  banners_conversts_send.psm
 bannert5$         "Inne Twoje auto juz wjechalo"    banners_conversts_send.psm
 bannert6$         "  Niepoprawny     format kodu"   banners_conversts_send.psm
 bannert7$         "Blad wewnetrzny  Przepraszamy"   banners_conversts_send.psm
 bannert8$         "     Zakaz          wyjazdu"     banners_conversts_send.psm
 ini_banner_msg$   "Podaj kod wjazdu>>"              banners_conversts_send.psm



List of line labels

   Label                   Addr  Source PSM File

 * cold_start              000   program.psm
 * main                    002   program.psm
   IR_petla1               002   program.psm
   IR_petla2               006   program.psm
   IR_czekaj               009   program.psm
 * IR_rx1                  00D   program.psm
   next_IR_bit1            00E   program.psm
 * IR_rx2                  014   program.psm
   next_IR_bit2            015   program.psm
 * IR_rx3                  01B   program.psm
   next_IR_bit3            01C   program.psm
 * after_filter            02E   program.psm
   LPC_THREAD              030   program.psm
   LPC_DV_down             035   program.psm
   LPC_LCD_send            03C   program.psm
   UART_THREAD             040   program.psm
   send_CR                 048   program.psm
   send_space              04A   program.psm
   send_hex_byte           04C   program.psm
   hex_to_ASCII            058   program.psm
   number_char             05B   program.psm
   upper_case              05D   program.psm
   ASCII_to_hex            063   program.psm
   ASCII_letter            06D   program.psm
 * obtain_value            06F   program.psm
   obtain_digit            070   program.psm
   build_value             079   program.psm
 * send_integer            083   program.psm
   send_integer_loop       089   program.psm
   next_int_digit          08F   program.psm
   zero_integer            093   program.psm
   integer16_to_BCD        096   program.psm
   int_to_BCD_loop         097   program.psm
   divide_16bit_by_10      09D   program.psm
   div10_loop              0A4   program.psm
   div10_restore           0A9   program.psm
   div10_shifts            0AC   program.psm
   my_delay_ir_bit         0B2   program.psm
 * delay_ir_bit            0B6   program.psm
 * delay_ir_half_bit       0BA   program.psm
   delay_ir_1_8_bit        0BE   program.psm
 * delay_200ms             0C2   program.psm
   delay_1s                0C6   program.psm
 * delay_1ms               0CA   program.psm
 * delay_40ms              0CE   program.psm
 * delay_2s                0D2   program.psm
   delay_5s                0D6   program.psm
   software_delay          0DC   program.psm
   reset_UART_macros       0E2   communication_routines.psm
 * reset_lcd_en_status     0E5   communication_routines.psm
 * reset_Eth_en_status     0E7   communication_routines.psm
   UART_TX                 0E9   communication_routines.psm
   LCD_send                0EE   communication_routines.psm
   LCD_czy_odebral         0F3   communication_routines.psm
   LPC_send                0F8   communication_routines.psm
   LPC_czy_odebral         0FD   communication_routines.psm
   petla                   102   communication_routines.psm
   UART_RX                 104   communication_routines.psm
   rx_timeout              105   communication_routines.psm
   read_Rx                 10B   communication_routines.psm
   convert_send            10D   banners_conversts_send.psm
   next_button1            115   banners_conversts_send.psm
   next_button2            11D   banners_conversts_send.psm
   next_button3            125   banners_conversts_send.psm
   next_button4            12D   banners_conversts_send.psm
   next_button5            135   banners_conversts_send.psm
   next_button6            13D   banners_conversts_send.psm
   next_button7            145   banners_conversts_send.psm
   next_button8            14D   banners_conversts_send.psm
   next_button9            155   banners_conversts_send.psm
   next_button10           15D   banners_conversts_send.psm
   next_button11           165   banners_conversts_send.psm
   which_banner            16D   banners_conversts_send.psm
   next_banner1            176   banners_conversts_send.psm
   IR_czekaj_na_przejazd   17E   banners_conversts_send.psm
   next_banner2            184   banners_conversts_send.psm
   next_banner3            18D   banners_conversts_send.psm
   next_banner4            196   banners_conversts_send.psm
   next_banner5            19F   banners_conversts_send.psm
   next_banner6            1A8   banners_conversts_send.psm
   next_banner7            1B1   banners_conversts_send.psm
   just_return             1BA   banners_conversts_send.psm
   send_message            1BB   banners_conversts_send.psm
   banner_message          1C2   banners_conversts_send.psm
   banner_msg              1C7   banners_conversts_send.psm
   banner2_message         1D6   banners_conversts_send.psm
   banner2_msg             1DB   banners_conversts_send.psm
   banner3_message         1FA   banners_conversts_send.psm
   banner3_msg             1FF   banners_conversts_send.psm
   banner4_message         210   banners_conversts_send.psm
   banner4_msg             215   banners_conversts_send.psm
   banner5_message         234   banners_conversts_send.psm
   banner5_msg             239   banners_conversts_send.psm
   banner6_message         256   banners_conversts_send.psm
   banner6_msg             25B   banners_conversts_send.psm
   banner7_message         279   banners_conversts_send.psm
   banner7_msg             27E   banners_conversts_send.psm
   banner8_message         29C   banners_conversts_send.psm
   banner8_msg             2A1   banners_conversts_send.psm
   ini_banner              2BD   banners_conversts_send.psm
   ini_banner_lr           2C2   banners_conversts_send.psm
   send_banner             2D5   banners_conversts_send.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            118
 STAR              -

 AND               2
 OR                1
 XOR               -

 ADD              11
 ADDCY             3
 SUB              36
 SUBCY             3

 TEST             34
 TESTCY            -
 COMPARE           8
 COMPARECY         1

 SL0               2
 SL1               1
 SLX               -
 SLA               7
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               1
 RR                -

 REGBANK           -

 INPUT            17
 OUTPUT            3
 OUTPUTK          10

 STORE             1
 FETCH             1

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             86
 JUMP@             -
 CALL             81
 CALL@             2
 RETURN           59
 LOAD&RETURN     230

 HWBUILD           9



End of KCPSM6 log file.
