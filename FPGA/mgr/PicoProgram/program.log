KCPSM6 Assembler log file for program 'C:\studia\MGR\FPGA\mgr\PicoProgram\program.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 05 Dec 2015
Assembly timestamp: 17:00:23

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 2A5 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 678
Memory locations available: 3418


Assembly listing

 Addr Code                          Instruction

 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Copyright © 2011-2013, Xilinx, Inc.
 000                                ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 000                                ; protected under U.S. and international copyright and other intellectual property laws.
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; Disclaimer:
 000                                ; This disclaimer is not a license and does not grant any rights to the materials
 000                                ; distributed herewith. Except as otherwise provided in a valid license issued to
 000                                ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 000                                ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 000                                ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 000                                ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 000                                ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 000                                ; (whether in contract or tort, including negligence, or under any other theory
 000                                ; of liability) for any loss or damage of any kind or nature related to, arising
 000                                ; under or in connection with these materials, including for any direct, or any
 000                                ; indirect, special, incidental, or consequential loss or damage (including loss
 000                                ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 000                                ; of any action brought by a third party) even if such damage or loss was
 000                                ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 000                                ;
 000                                ; CRITICAL APPLICATIONS
 000                                ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 000                                ; application requiring fail-safe performance, such as life-support or safety
 000                                ; devices or systems, Class III medical devices, nuclear facilities, applications
 000                                ; related to the deployment of airbags, or any other applications that could lead
 000                                ; to death, personal injury, or severe property or environmental damage
 000                                ; (individually and collectively, "Critical Applications"). Customer assumes the
 000                                ; sole risk and liability of any use of Xilinx products in Critical Applications,
 000                                ; subject only to applicable laws and regulations governing limitations on product
 000                                ; liability.
 000                                ;
 000                                ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ;
 000                                ;             _  ______ ____  ____  __  __  __
 000                                ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 000                                ;            | ' / |   | |_) \___ \| |\/| | '_ \
 000                                ;            | . \ |___|  __/ ___) | |  | | (_) )
 000                                ;            |_|\_\____|_|   |____/|_|  |_|\___/
 000                                ;
 000                                ;
 000                                ; KCPSM6 reference design using 'uart_tx6' and 'uart_rx6' macros.
 000                                ;
 000                                ; Ken Chapman - Xilinx Ltd
 000                                ;
 000                                ;      11th May 2011 - Initial version
 000                                ;   6th October 2011 - Corrections to comments only
 000                                ;    23rd April 2012 - UART interface routines placed into 'uart_interface_routines.psm'
 000                                ;                      to facilitate reuse and provide an INCLUDE directive example.
 000                                ; 7th September 2012 - Corrections to comments only
 000                                ;    12th March 2013 - Constant directives defining ASCII control characters removed
 000                                ;                        (pre-defined in KCPSM6 assembler v2.43 or later).
 000                                ;     28th June 2013 - Corrections to comment only
 000                                ;
 000                                ;
 000                                ; INTRODUCTION
 000                                ;
 000                                ; This program interacts with the 'uart_tx6' and 'uart_rx6' macros providing some simple
 000                                ; and fundamental examples of UART based communication. As such, this example is intended
 000                                ; to display messages on a PC based terminal (e.g. PicoTerm or HyperTerminal) and receive
 000                                ; inputs typed on a keyboard by the user.
 000                                ;
 000                                ; The user is prompted to enter a 4-digit hexadecimal value which KCPSM6 converts to
 000                                ; decimal and displays if it is valid. It is hoped that this will also provide you with
 000                                ; several routines that you will find useful in your own programs.
 000                                ;
 000                                ; Please see 'UART6_User_Guide_30Sept12.pdf' for more detailed descriptions of the
 000                                ; hardware circuit. The 'UART_TX' and 'UART_RX' routines that form the software interface
 000                                ; with the macros are contained in 'uart_interface_routines.psm' together with a set of
 000                                ; constants which define the allocation of I/O ports and the signals within them. The
 000                                ; 'uart_interface_routines.psm' also presents an example of using the INCLUDE directive
 000                                ; introduced with KCPSM6 Assembler v2.00.
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Port definitions
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; The only I/O ports used in this design are those that interface with the UART macros.
 000                                ; CONSTANT directives defining the port addresses and the allocation of signals within
 000                                ; those ports are defined in 'uart_interface_routines.psm'.
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Special Register usage
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; No registers are given special names in this program.
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Scratch Pad Memory Locations
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                CONSTANT hex_value0, 00                                ;16-bit value (lower byte)
 000                                CONSTANT hex_value1, 01                                ;16-bit value (upper byte)
 000                                ;
 000                                CONSTANT decimal0, 02                                  ;5 digit decimal value
 000                                CONSTANT decimal1, 03                                  ;  Suitable for 16-bit values up to
 000                                CONSTANT decimal2, 04                                  ;   65,536
 000                                CONSTANT decimal3, 05
 000                                CONSTANT decimal4, 06
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Useful data constants
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ;
 000                                ;
 000                                ;------------------------------------------------------------------------------------------
 000                                ; Initialise the system
 000                                ;------------------------------------------------------------------------------------------
 000                                ;
 000                                ; A delay of 1 second is implemented which is intended to give time for all the hardware
 000                                ; to settle into a stable condition before starting to doing anything. This can be
 000                                ; particularly beneficial when dealing with long cables where serial lines can take some
 000                                ; time to reach the initial idle state following power being applied.
 000                                ;
 000  200BC             cold_start: CALL 0BC[delay_1s]                                     ;
 001                                ;
 001  200D8                         CALL 0D8[reset_UART_macros]                            ;Reset buffers in UART macros
 002                                ;
 002                                ;
 002                                ; Initialised terminal display and display welcome messages
 002                                ;
 002                                ;CALL clear_screen
 002                                ;CALL welcome_message
 002                                ;
 002                                ;
 002                                ;------------------------------------------------------------------------------------------
 002                                ; Main Program
 002                                ;------------------------------------------------------------------------------------------
 002                                ;
 002                                ;
 002                          main: 
 002                                ;jump UART_THREAD
 002                                ;jump LPC_THREAD
 002  01708              IR_petla1: LOAD s7, 08
 003  01F1B                         LOAD sF, 1B[ESC]
 004  200E4                         CALL 0E4[LCD_send]
 005  20287                         CALL 287[ini_banner]
 006  01A00              IR_petla2: LOAD sA, 00[00000000'b]
 007  01B00                         LOAD sB, 00[00000000'b]
 008  01C00                         LOAD sC, 00[00000000'b]
 009  0900B              IR_czekaj: INPUT s0, 0B[IR_PORT]
 00A  0D001                         TEST s0, 01[00000001'b]
 00B  3A009                         JUMP C, 009[IR_czekaj]
 00C  200B4                         CALL 0B4[delay_ir_1_8_bit]
 00D  01403                 IR_rx1: LOAD s4, 03                                            ;8-bits to transmit and receive
 00E  200A8           next_IR_bit1: CALL 0A8[my_delay_ir_bit]                              ;prepare next bit to transmit
 00F  0930B                         INPUT s3, 0B[IR_PORT]                                  ;read input bit
 010  0D301                         TEST s3, 01[00000001'b]                                ;carry flag becomes value of received bit
 011  14A00                         SLA sA                                                 ;shift new data into result and move to next transmit bit
 012  19401                         SUB s4, 01                                             ;count bits
 013  3600E                         JUMP NZ, 00E[next_IR_bit1]                             ;repeat until last bit
 014  01405                 IR_rx2: LOAD s4, 05                                            ;8-bits to transmit and receive
 015  200A8           next_IR_bit2: CALL 0A8[my_delay_ir_bit]                              ;prepare next bit to transmit
 016  0930B                         INPUT s3, 0B[IR_PORT]                                  ;read input bit
 017  0D301                         TEST s3, 01[00000001'b]                                ;carry flag becomes value of received bit
 018  14B00                         SLA sB                                                 ;shift new data into result and move to next transmit bit
 019  19401                         SUB s4, 01                                             ;count bits
 01A  36015                         JUMP NZ, 015[next_IR_bit2]                             ;repeat until last bit
 01B  01406                 IR_rx3: LOAD s4, 06                                            ;8-bits to transmit and receive
 01C  200A8           next_IR_bit3: CALL 0A8[my_delay_ir_bit]                              ;prepare next bit to transmit
 01D  0930B                         INPUT s3, 0B[IR_PORT]                                  ;read input bit
 01E  0D301                         TEST s3, 01[00000001'b]                                ;carry flag becomes value of received bit
 01F  14C00                         SLA sC                                                 ;shift new data into result and move to next transmit bit
 020  19401                         SUB s4, 01                                             ;count bits
 021  3601C                         JUMP NZ, 01C[next_IR_bit3]                             ;repeat until last bit
 022  2003E                         CALL 03E[send_CR]
 023  004A0                         LOAD s4, sA
 024                                ;call send_hex_byte
 024                                ;CALL send_space
 024                                ;load s4, sB
 024                                ;call send_hex_byte
 024                                ;CALL send_space
 024                                ;load s4, sC
 024                                ;call send_hex_byte
 024  2010B                         CALL 10B[convert_send]
 025  36006                         JUMP NZ, 006[IR_petla2]
 026  2B01A             LPC_THREAD: OUTPUTK 01[LPC_ready_syg], A[LPC_IN_ready_port]
 027  09009                         INPUT s0, 09[LPC_IN_data_valid_port]
 028  0D001                         TEST s0, 01[LPC_data_valid_syg]                        ;Z=0 and C=1 when data present
 029  32026                         JUMP Z, 026[LPC_THREAD]
 02A  09508                         INPUT s5, 08[LPC_IN_data_port]
 02B  2B00A            LPC_DV_down: OUTPUTK 00[00000000'b], A[LPC_IN_ready_port]
 02C  09009                         INPUT s0, 09[LPC_IN_data_valid_port]                   ;Sprawdza czy driver odebra³ dane
 02D  0D001                         TEST s0, 01[LPC_data_valid_syg]
 02E  3A02B                         JUMP C, 02B[LPC_DV_down]
 02F  20163                         CALL 163[which_banner]
 030  200CC                         CALL 0CC[delay_5s]
 031  22002                         JUMP 002[IR_petla1]
 032  200E4           LPC_LCD_send: CALL 0E4[LCD_send]
 033  200EE                         CALL 0EE[LPC_send]
 034  19701                         SUB s7, 01
 035  25000                         RETURN 
 036  09000            UART_THREAD: INPUT s0, 00[UART_status_port]
 037  0D008                         TEST s0, 08[UART_Rx_data_present]                      ;Z=0 and C=1 when data present
 038  32036                         JUMP Z, 036[UART_THREAD]
 039  09501                         INPUT s5, 01[UART_RX6_input_port]
 03A  00F50                         LOAD sF, s5
 03B                                ;CALL UART_TX
 03B  200EE                         CALL 0EE[LPC_send]
 03C  200E4                         CALL 0E4[LCD_send]
 03D  22036                         JUMP 036[UART_THREAD]
 03E                                ;
 03E                                ;
 03E                                ;------------------------------------------------------------------------------------------
 03E                                ; Send Carriage Return to UART
 03E                                ;------------------------------------------------------------------------------------------
 03E                                ;
 03E                                ; Registers used s0, s1, s2, and s
 03E  0150D                send_CR: LOAD s5, 0D[CR]
 03F  220DF                         JUMP 0DF[UART_TX]                                      ;includes RETURN
 040                                ;
 040                                ;
 040                                ;------------------------------------------------------------------------------------------
 040                                ; Send a Space to UART
 040                                ;------------------------------------------------------------------------------------------
 040                                ;
 040                                ; Registers used s0, s1, s2, and s5.
 040                                ;
 040  01520             send_space: LOAD s5, 20[" "]
 041  220DF                         JUMP 0DF[UART_TX]                                      ;includes RETURN
 042                                ;
 042                                ;
 042                                ;------------------------------------------------------------------------------------------
 042                                ; Send Hex Value of 16-bit word to UART
 042                                ;------------------------------------------------------------------------------------------
 042                                ;
 042                                ; Value provided in register pair [sB,sA] is sent as ASCII HEX to the UART
 042                                ; transmitter.
 042                                ;
 042                                ; Registers used s0, s1, s2, s4, s5, sA and sB.
 042                                ;
 042                                ;
 042                                ;------------------------------------------------------------------------------------------
 042                                ; Send Hex Value of Byte to UART
 042                                ;------------------------------------------------------------------------------------------
 042                                ;
 042                                ; Value provided in register 's4' is sent as ASCII HEX to the UART transmitter.
 042                                ;
 042                                ; Registers used s0, s4 (preserved) and s5.
 042                                ;
 042  00540          send_hex_byte: LOAD s5, s4                                            ;isolate upper nibble
 043  1450E                         SR0 s5
 044  1450E                         SR0 s5
 045  1450E                         SR0 s5
 046  1450E                         SR0 s5
 047  2004E                         CALL 04E[hex_to_ASCII]                                 ; convert to ASCII
 048  200DF                         CALL 0DF[UART_TX]                                      ;send upper digit to UART
 049  00540                         LOAD s5, s4                                            ;isolate lower nibble
 04A  0350F                         AND s5, 0F
 04B  2004E                         CALL 04E[hex_to_ASCII]                                 ; convert to ASCII
 04C  200DF                         CALL 0DF[UART_TX]                                      ;send lower digit to UART
 04D  25000                         RETURN 
 04E                                ;
 04E                                ; Convert value 00 to 0F provided in 's5' into ASCII character in 's5'
 04E                                ;
 04E                                ; Register used s5
 04E                                ;
 04E  1950A           hex_to_ASCII: SUB s5, 0A                                             ;test if value is in range 0 to 9
 04F  3A051                         JUMP C, 051[number_char]
 050  11507                         ADD s5, 07                                             ;ASCII char A to F in range 41 to 46
 051  1153A            number_char: ADD s5, 3A                                             ;ASCII char 0 to 9 in range 30 to 40
 052  25000                         RETURN 
 053                                ;
 053                                ;
 053                                ;------------------------------------------------------------------------------------------
 053                                ; Converts character to upper case
 053                                ;------------------------------------------------------------------------------------------
 053                                ;
 053                                ; Tests and converts character in 's5' (if necessary).
 053                                ;
 053                                ; To convert character to upper case
 053                                ;
 053                                ; If the character is in the range 'a' to 'z', it is converted
 053                                ; to the equivalent upper case character in the range 'A' to 'Z'.
 053                                ; All other characters remain unchanged.
 053                                ;
 053  1D561             upper_case: COMPARE s5, 61["a"]                                    ;eliminate character codes below 'a' (61 hex)
 054  39000                         RETURN C
 055  1D57B                         COMPARE s5, 7B                                         ;eliminate character codes above 'z' (7A hex)
 056  3D000                         RETURN NC
 057  035DF                         AND s5, DF[11011111'b]                                 ;force bit5 Low to convert to upper case
 058  25000                         RETURN 
 059                                ;
 059                                ;
 059                                ;------------------------------------------------------------------------------------------
 059                                ; Convert ASCII character to an equivalent HEX value.
 059                                ;------------------------------------------------------------------------------------------
 059                                ;
 059                                ; Converts the ASCII character presented in 's5' to an equivalent HEX value.
 059                                ; If character is not valid for hex, then CARRY is set on return.
 059                                ;
 059                                ; Register used s5
 059                                ;
 059  115B9           ASCII_to_hex: ADD s5, B9                                             ;test for above ASCII code 46 ('F')
 05A  39000                         RETURN C
 05B  195E9                         SUB s5, E9                                             ;normalise 0 to 9 with A-F in 11 to 16 hex
 05C  39000                         RETURN C                                               ;reject below ASCII code 30 ('0')
 05D  19511                         SUB s5, 11                                             ;isolate A-F down to 00 to 05 hex
 05E  3E063                         JUMP NC, 063[ASCII_letter]
 05F  11507                         ADD s5, 07                                             ;test for above ASCII code 46 ('F')
 060  39000                         RETURN C
 061  195F6                         SUB s5, F6                                             ;convert to range 00 to 09
 062  25000                         RETURN 
 063  1150A           ASCII_letter: ADD s5, 0A                                             ;convert to range 0A to 0F
 064  25000                         RETURN 
 065                                ;
 065                                ;
 065                                ;------------------------------------------------------------------------------------------
 065                                ; Read ASCII-HEX value up to 8-digits (for 32-bit value) from UART
 065                                ;------------------------------------------------------------------------------------------
 065                                ;
 065                                ; Read up to 8 hex characters from UART and convert to a binary value in the [sD,sC,sB,sA]
 065                                ; register set. The number of characters to be read must be defined in sE. When less than
 065                                ; 8 characters are read the value is returned in the least significant bits of the register
 065                                ; set with the 8-bits above the defined value being zero to ensure ensuring that the upper
 065                                ; nibble will be zero if an odd number of digits are read.
 065                                ;
 065                                ; If any character received from the UART is not in the range 0 to F then the routine will
 065                                ; end immediately with the CARRY flag set and this should be checked by the calling process
 065                                ; upon return.
 065                                ;
 065  01A00           obtain_value: LOAD sA, 00                                            ;initialise potentially unused bits to zero
 066  200FA           obtain_digit: CALL 0FA[UART_RX]                                      ;wait for a character and return in s5
 067  32066                         JUMP Z, 066[obtain_digit]                              ;continue to wait if timeout occurs
 068  200DF                         CALL 0DF[UART_TX]                                      ;echo character as entered
 069  200DF                         CALL 0DF[UART_TX]
 06A  200DF                         CALL 0DF[UART_TX]
 06B  20053                         CALL 053[upper_case]                                   ;convert to upper case if necessary
 06C  20059                         CALL 059[ASCII_to_hex]                                 ;convert value in s5 to hex nibble
 06D  39000                         RETURN C                                               ;If invalid hex digit then return immediately
 06E  01004                         LOAD s0, 04[4'd]                                       ;shift [sD,sC,sB,sA] left by 4 bits
 06F  14A06            build_value: SL0 sA                                                 ;  to make space for new digit value
 070  14B00                         SLA sB
 071  14C00                         SLA sC
 072  14D00                         SLA sD
 073  19001                         SUB s0, 01[1'd]
 074  3606F                         JUMP NZ, 06F[build_value]
 075  04A50                         OR sA, s5                                              ;merge value of new digit into existing value
 076  19E01                         SUB sE, 01                                             ;count number of digits obtained
 077  36066                         JUMP NZ, 066[obtain_digit]
 078  25000                         RETURN 
 079                                ;
 079                                ;
 079                                ;------------------------------------------------------------------------------------------
 079                                ; Send integer in decimal format to UART Tx
 079                                ;------------------------------------------------------------------------------------------
 079                                ;
 079                                ; The 16-bit value provided in [s3,s2] should be a positive integer and will be displayed
 079                                ; using 1 to 5 digits for values up to 65535 (i.e. leading zeros are blanked).
 079                                ;
 079                                ;
 079  1D200           send_integer: COMPARE s2, 00                                         ;test for special case of zero
 07A  1F300                         COMPARECY s3, 00
 07B  32089                         JUMP Z, 089[zero_integer]
 07C                                ;
 07C  2008C                         CALL 08C[integer16_to_BCD]                             ;Convert to BCD in SPM
 07D                                ;
 07D  01A06                         LOAD sA, 06[decimal4]                                  ;pointer to BCD in SPM
 07E  01B00                         LOAD sB, 00[0'd]                                       ;flag for leading zero blanking
 07F  0A5A0      send_integer_loop: FETCH s5, (sA)
 080  10B50                         ADD sB, s5                                             ;make sB non-zero to stop blanking
 081  1DB00                         COMPARE sB, 00[0'd]                                    ;Test for blanking
 082  32085                         JUMP Z, 085[next_int_digit]
 083  11530                         ADD s5, 30["0"]                                        ;convert to ASCII
 084  200DF                         CALL 0DF[UART_TX]                                      ;send digit
 085  1DA02         next_int_digit: COMPARE sA, 02[decimal0]
 086  31000                         RETURN Z
 087  19A01                         SUB sA, 01[1'd]                                        ;move pointer to next digit
 088  2207F                         JUMP 07F[send_integer_loop]
 089                                ;
 089  01530           zero_integer: LOAD s5, 30["0"]                                       ;special response for zero
 08A  200DF                         CALL 0DF[UART_TX]
 08B  25000                         RETURN 
 08C                                ;
 08C                                ;
 08C                                ;------------------------------------------------------------------------------------------
 08C                                ; 16-bit integer to BCD conversion
 08C                                ;------------------------------------------------------------------------------------------
 08C                                ;
 08C                                ; Convert the 16 bit value up to FFFF hex in register set [s3,s2]
 08C                                ; into the BCD decimal equivalent up to 65,535 located in the scratch pad memory
 08C                                ; locations 'decimal0' to 'decimal4' which must be in ascending locations.
 08C                                ;
 08C                                ; Each digit is formed in turn starting with the least significant. The value
 08C                                ; contained in [s3,s2] is divided by 10 and the remainder of that integer division
 08C                                ; is the value of each digit in the range 0 to 9.
 08C                                ;
 08C                                ; Registers used s0,s2,s3,s4,s8,s9,sA,sB
 08C                                ;
 08C  01402       integer16_to_BCD: LOAD s4, 02[decimal0]                                  ;pointer for LS-Digit in scratch pad memory
 08D  20093        int_to_BCD_loop: CALL 093[divide_16bit_by_10]
 08E  2EA40                         STORE sA, (s4)                                         ;remainder is the digit value
 08F  1D406                         COMPARE s4, 06[decimal4]                               ;test for MS-Digit completed
 090  31000                         RETURN Z
 091  11401                         ADD s4, 01[1'd]                                        ;advance pointer to next digit
 092  2208D                         JUMP 08D[int_to_BCD_loop]
 093                                ;
 093                                ; Divide 16-bit binary integer by 10
 093                                ;
 093                                ; The value to be divided by 10 should be provided in register set [s3,s2].
 093                                ; The routine will return the integer result [s3,s2]/10 back in[s3,s2]
 093                                ; with any remainder in (0 to 9) in register sA.
 093                                ;
 093                                ; Registers used s0,s2,s3,s8,s9,sA,sB
 093                                ;
 093  00A20     divide_16bit_by_10: LOAD sA, s2                                            ;copy input value into [sB,sA]
 094  00B30                         LOAD sB, s3
 095  01200                         LOAD s2, 00                                            ;clear division result
 096  01300                         LOAD s3, 00
 097  019A0                         LOAD s9, A0                                            ;initialise [s9,s8] with '10' in MSBs
 098  01800                         LOAD s8, 00
 099  0100D                         LOAD s0, 0D[13'd]                                      ;13 subtract and shift iterations to be performed
 09A  18A80             div10_loop: SUB sA, s8                                             ;perform 16-bit subtract [sB,sA]-[s9,s8]
 09B  1AB90                         SUBCY sB, s9
 09C  3A09F                         JUMP C, 09F[div10_restore]                             ;if carry then could not subtract from total
 09D  14207                         SL1 s2                                                 ;shift '1' into result because subtract ok
 09E  220A2                         JUMP 0A2[div10_shifts]
 09F  10A80          div10_restore: ADD sA, s8                                             ;perform 16-bit addition [sB,sA]+[s9,s8]
 0A0  12B90                         ADDCY sB, s9                                           ;to restore total
 0A1  14206                         SL0 s2                                                 ;shift '0' into result because could no subtract
 0A2  14300           div10_shifts: SLA s3                                                 ;complete 16-bit shift left into [s3,s2]
 0A3  1490E                         SR0 s9                                                 ;divide '10' value by 2 (shift right 1 place)
 0A4  14808                         SRA s8
 0A5  19001                         SUB s0, 01                                             ;count iterations
 0A6  31000                         RETURN Z                                               ;on return the remainder of division is in sA
 0A7  2209A                         JUMP 09A[div10_loop]
 0A8                                ;
 0A8                                ;
 0A8                                ;------------------------------------------------------------------------------------------
 0A8                                ; Include PSM files
 0A8                                ;------------------------------------------------------------------------------------------
 0A8                                ;
 0A8                                ; The INCLUDE directive enables commonly routines to be kept in their own PSM files and
 0A8                                ; easily reused in different programs (i.e. avoiding 'cut and paste'). It also allows
 0A8                                ; each PSM to remain a more manageable size.
 0A8                                ;
 0A8                                ;
 0A8  01200        my_delay_ir_bit: LOAD s2, 00
 0A9  01122                         LOAD s1, 22
 0AA  010BA                         LOAD s0, BA
 0AB  220D2                         JUMP 0D2[software_delay]
 0AC  01200           delay_ir_bit: LOAD s2, 00
 0AD  01122                         LOAD s1, 22
 0AE  010BA                         LOAD s0, BA
 0AF  220D2                         JUMP 0D2[software_delay]
 0B0  01200      delay_ir_half_bit: LOAD s2, 00
 0B1  01111                         LOAD s1, 11
 0B2  0105D                         LOAD s0, 5D
 0B3  220D2                         JUMP 0D2[software_delay]
 0B4  01200       delay_ir_1_8_bit: LOAD s2, 00
 0B5  01104                         LOAD s1, 04
 0B6  01057                         LOAD s0, 57
 0B7  220D2                         JUMP 0D2[software_delay]
 0B8  0121E            delay_200ms: LOAD s2, 1E
 0B9  01184                         LOAD s1, 84
 0BA  01010                         LOAD s0, 10
 0BB  220D2                         JUMP 0D2[software_delay]
 0BC  0125F               delay_1s: LOAD s2, 5F
 0BD  0115E                         LOAD s1, 5E
 0BE  01010                         LOAD s0, 10
 0BF  220D2                         JUMP 0D2[software_delay]
 0C0                                ;
 0C0                                ; 2ms is 10,000 x 200ns     (10,000 = 002710 hex)
 0C0  01200              delay_1ms: LOAD s2, 00                                            ;2ms !
 0C1  01127                         LOAD s1, 27
 0C2  01010                         LOAD s0, 10
 0C3  220D2                         JUMP 0D2[software_delay]
 0C4                                ;
 0C4                                ; 40ms is 200,000 x 200ns     (200,000 = 030D40 hex)
 0C4                                ;
 0C4  01203             delay_40ms: LOAD s2, 03
 0C5  0110D                         LOAD s1, 0D
 0C6  01040                         LOAD s0, 40
 0C7  220D2                         JUMP 0D2[software_delay]
 0C8                                ;
 0C8                                ;
 0C8                                ; 2s is 10,000,000 x 200ns     (10,000,000 = 989680 hex)
 0C8                                ;
 0C8  01298               delay_2s: LOAD s2, 98
 0C9  01196                         LOAD s1, 96
 0CA  01080                         LOAD s0, 80
 0CB  220D2                         JUMP 0D2[software_delay]
 0CC  200BC               delay_5s: CALL 0BC[delay_1s]
 0CD  200BC                         CALL 0BC[delay_1s]
 0CE  200BC                         CALL 0BC[delay_1s]
 0CF  200BC                         CALL 0BC[delay_1s]
 0D0  200BC                         CALL 0BC[delay_1s]
 0D1  25000                         RETURN 
 0D2                                ;
 0D2                                ; The delay loop decrements [s2,s1,s0] until it reaches zero
 0D2                                ; Each decrement cycle is 5 instructions which is 10 clock cycles (100ns at 100MHz)
 0D2                                ;
 0D2  00000         software_delay: LOAD s0, s0                                            ;pad loop to make it 10 clock cycles (5 instructions) 200ns u mnie
 0D3  19001                         SUB s0, 01[1'd]
 0D4  1B100                         SUBCY s1, 00[0'd]
 0D5  1B200                         SUBCY s2, 00[0'd]
 0D6  360D2                         JUMP NZ, 0D2[software_delay]
 0D7  25000                         RETURN 
 0D8                                ; Include routines that implement interface with UART macros.
 0D8                                ; -----------------------------------------------------------
 0D8                                ;
 0D8                                INCLUDE "C:\studia\MGR\FPGA\mgr\PicoProgram\communication_routines.psm"["communication_routines.psm"]
 0D8                                ;
 0D8                                ;------------------------------------------------------------------------------------------
 0D8                                ; Copyright © 2011-2012, Xilinx, Inc.
 0D8                                ; This file contains confidential and proprietary information of Xilinx, Inc. and is
 0D8                                ; protected under U.S. and international copyright and other intellectual property laws.
 0D8                                ;------------------------------------------------------------------------------------------
 0D8                                ;
 0D8                                ; Disclaimer:
 0D8                                ; This disclaimer is not a license and does not grant any rights to the materials
 0D8                                ; distributed herewith. Except as otherwise provided in a valid license issued to
 0D8                                ; you by Xilinx, and to the maximum extent permitted by applicable law: (1) THESE
 0D8                                ; MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL FAULTS, AND XILINX HEREBY
 0D8                                ; DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY,
 0D8                                ; INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT,
 0D8                                ; OR FITNESS FOR ANY PARTICULAR PURPOSE; and (2) Xilinx shall not be liable
 0D8                                ; (whether in contract or tort, including negligence, or under any other theory
 0D8                                ; of liability) for any loss or damage of any kind or nature related to, arising
 0D8                                ; under or in connection with these materials, including for any direct, or any
 0D8                                ; indirect, special, incidental, or consequential loss or damage (including loss
 0D8                                ; of data, profits, goodwill, or any type of loss or damage suffered as a result
 0D8                                ; of any action brought by a third party) even if such damage or loss was
 0D8                                ; reasonably foreseeable or Xilinx had been advised of the possibility of the same.
 0D8                                ;
 0D8                                ; CRITICAL APPLICATIONS
 0D8                                ; Xilinx products are not designed or intended to be fail-safe, or for use in any
 0D8                                ; application requiring fail-safe performance, such as life-support or safety
 0D8                                ; devices or systems, Class III medical devices, nuclear facilities, applications
 0D8                                ; related to the deployment of airbags, or any other applications that could lead
 0D8                                ; to death, personal injury, or severe property or environmental damage
 0D8                                ; (individually and collectively, "Critical Applications"). Customer assumes the
 0D8                                ; sole risk and liability of any use of Xilinx products in Critical Applications,
 0D8                                ; subject only to applicable laws and regulations governing limitations on product
 0D8                                ; liability.
 0D8                                ;
 0D8                                ; THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE AT ALL TIMES.
 0D8                                ;
 0D8                                ;------------------------------------------------------------------------------------------
 0D8                                ;
 0D8                                ;             _  ______ ____  ____  __  __  __
 0D8                                ;            | |/ / ___|  _ \/ ___||  \/  |/ /_
 0D8                                ;            | ' / |   | |_) \___ \| |\/| | '_ \
 0D8                                ;            | . \ |___|  __/ ___) | |  | | (_) )
 0D8                                ;            |_|\_\____|_|   |____/|_|  |_|\___/
 0D8                                ;
 0D8                                ;
 0D8                                ;                PicoBlaze Reference Design.
 0D8                                ;
 0D8                                ;
 0D8                                ; Ken Chapman - Xilinx Ltd
 0D8                                ;
 0D8                                ; 23rd April 2012 - Initial Release
 0D8                                ; 24th July 2012 - Corrections to comments only
 0D8                                ;
 0D8                                ; This file contains routines used to interface with the UART6 macros provided with KCPSM6
 0D8                                ; and was first supplied with a reference design called 'uart6_605' included in the
 0D8                                ; PicoBlaze package. The routines enable characters to be transmitted to and received
 0D8                                ; from the UART macros as well as perform a reset of the FIFO the buffers.
 0D8                                ;
 0D8                                ;     NOTE - This is not a standalone PSM file. The 'uart_control.psm' file supplied with
 0D8                                ;            the reference design stated above includes this file and calls the routines
 0D8                                ;            contained in this file.
 0D8                                ;
 0D8                                ;                INCLUDE "uart_interface_routines.psm"
 0D8                                ;
 0D8                                ;     Hint - The INCLUDE directive was introduced in KCPSM6 Assembler v2.00.
 0D8                                ;
 0D8                                ;
 0D8                                ; Whilst the reference design stated above was presented for the UART macros connected to
 0D8                                ; the USB/UART interface on the Xilinx ML605 Evaluation Kit this file can be ported to
 0D8                                ; any design for any board simply by setting the appropriate values in the CONSTANT
 0D8                                ; directives described below.
 0D8                                ;
 0D8                                ;
 0D8                                ;------------------------------------------------------------------------------------------
 0D8                                ; Hardware Constants
 0D8                                ;------------------------------------------------------------------------------------------
 0D8                                ;
 0D8                                ; The CONSTANT directives below define the input and output ports assigned to the UART
 0D8                                ; macros that implement a 115,200 baud rate communication with the USB/UART on the board.
 0D8                                ; Additional constants identify the allocation of signals to bits within a port.
 0D8                                ;
 0D8                                ;
 0D8                                ;
 0D8                                ; UART Status
 0D8                                ; -----------
 0D8                                ;
 0D8                                CONSTANT UART_status_port, 00                          ; Read status
 0D8                                CONSTANT UART_Tx_data_present, 00000001'b              ; Tx   data_present - bit0
 0D8                                CONSTANT UART_Tx_half_full, 00000010'b                 ;         half_full - bit1
 0D8                                CONSTANT UART_Tx_full, 00000100'b                      ;              full - bit2
 0D8                                CONSTANT UART_Rx_data_present, 00001000'b              ; Rx   data_present - bit3
 0D8                                CONSTANT UART_Rx_half_full, 00010000'b                 ;         half_full - bit4
 0D8                                CONSTANT UART_Rx_full, 00100000'b                      ;              full - bit5
 0D8                                ;
 0D8                                ; Write data to UART_TX6
 0D8                                ; ----------------------
 0D8                                ;
 0D8                                CONSTANT UART_TX6_output_port, 01
 0D8                                ;
 0D8                                ; Read data from UART_RX6
 0D8                                ; -----------------------
 0D8                                ;
 0D8                                CONSTANT UART_RX6_input_port, 01
 0D8                                ;
 0D8                                ; Reset UART buffers (Constant Optimised Port)
 0D8                                ; --------------------------------------------
 0D8                                ;
 0D8                                CONSTANT LCD_driver_send_port, 02
 0D8                                CONSTANT LCD_driver_en_port, 03
 0D8                                CONSTANT LCD_driver_ready_port, 04
 0D8                                CONSTANT LPC_data_port, 05
 0D8                                CONSTANT LPC_data_valid_port, 06
 0D8                                CONSTANT LPC_ready_port, 07
 0D8                                CONSTANT LPC_IN_data_port, 08                          ; from LPC
 0D8                                CONSTANT LPC_IN_data_valid_port, 09                    ; from LPC
 0D8                                CONSTANT LPC_IN_ready_port, 0A                         ; to LPC
 0D8                                CONSTANT IR_PORT, 0B
 0D8                                CONSTANT reset_UART_port, 01
 0D8                                CONSTANT UART_tx_reset, 00000001'b                     ; uart_tx6 reset - bit0
 0D8                                CONSTANT UART_rx_reset, 00000010'b                     ; uart_rx6 reset - bit1
 0D8                                CONSTANT UART_reset, 00000011'b                        ; reset Tx and Rx
 0D8                                CONSTANT UART_operate, 00000000'b                      ; Tx and Rx free to operate
 0D8                                CONSTANT LCD_en_reset, 00000000'b                      ; reset lcd en
 0D8                                CONSTANT LCD_en_syg, 00000001'b                        ; send lcd en
 0D8                                CONSTANT LCD_ready_syg, 00000001'b                     ; send lcd en
 0D8                                CONSTANT LCD_odebral_syg, 00000000'b
 0D8                                CONSTANT LPC_ready_syg, 00000001'b                     ; LPC ready to get data
 0D8                                CONSTANT LPC_data_valid_syg, 00000001'b                ; Pico data valid
 0D8                                CONSTANT LPC_dv_reset, 00000000'b                      ; reset Eth en
 0D8                                ;
 0D8                                ;
 0D8                                ;--------------------------------------------------------------------------------------
 0D8                                ; Routine to reset UART Buffers inside 'uart_tx6' and 'uart_rx6'
 0D8                                ;--------------------------------------------------------------------------------------
 0D8                                ;
 0D8                                ; This routine will generate and apply an active High reset pulse to  the FIFO
 0D8                                ; buffers in both the transmitter and receiver macros.
 0D8                                ;
 0D8                                ; Note that the reset signals have been assigned to a constant optimised output port
 0D8                                ; so the 'OUTPUTK' instructions are used and no registers contents are affected.
 0D8                                ;
 0D8                                ;
 0D8  2B031      reset_UART_macros: OUTPUTK 03[UART_reset], 1[reset_UART_port]
 0D9  2B001                         OUTPUTK 00[UART_operate], 1[reset_UART_port]
 0DA  25000                         RETURN 
 0DB  2B003    reset_lcd_en_status: OUTPUTK 00[LCD_en_reset], 3[LCD_driver_en_port]
 0DC  25000                         RETURN 
 0DD  2B006    reset_Eth_en_status: OUTPUTK 00[LPC_dv_reset], 6[LPC_data_valid_port]
 0DE  25000                         RETURN 
 0DF                                ;
 0DF                                ;
 0DF                                ;--------------------------------------------------------------------------------------
 0DF                                ; Routine to send one character to the UART Transmitter 'uart_tx6'
 0DF                                ;--------------------------------------------------------------------------------------
 0DF                                ;
 0DF                                ; This routine will transmit the character provided in register 's5'.
 0DF                                ;
 0DF                                ; Before the character is output to the 'UART_TX6' macro the status of the FIFO buffer
 0DF                                ; is checked to see if there is space. If the buffer is full then this routine will
 0DF                                ; wait for space to become available (e.g. the time required for a previous character
 0DF                                ; to be transmitted by the UART).
 0DF                                ;
 0DF                                ; Registers used s0 and s5 for the data (which is preserved)
 0DF                                ;
 0DF  09000                UART_TX: INPUT s0, 00[UART_status_port]                         ;Check if buffer is full
 0E0  0D004                         TEST s0, 04[UART_Tx_full]
 0E1  360DF                         JUMP NZ, 0DF[UART_TX]                                  ;wait if full
 0E2  2D501                         OUTPUT s5, 01[UART_TX6_output_port]
 0E3  25000                         RETURN 
 0E4                                ;--------------------------------------------------------------------------------------
 0E4                                ; Routine to wywsy³anie znaków do drivera lcd
 0E4                                ;--------------------------------------------------------------------------------------
 0E4  09004               LCD_send: INPUT s0, 04[LCD_driver_ready_port]                    ;Sprawdza czy driver mo¿e odbieraæ dane
 0E5  0D001                         TEST s0, 01[LCD_ready_syg]
 0E6  320E4                         JUMP Z, 0E4[LCD_send]                                  ;czeka a¿ bêdzie gotowy
 0E7  2DF02                         OUTPUT sF, 02[LCD_driver_send_port]
 0E8  2B013                         OUTPUTK 01[LCD_en_syg], 3[LCD_driver_en_port]
 0E9  09004        LCD_czy_odebral: INPUT s0, 04[LCD_driver_ready_port]                    ;Sprawdza czy driver odebra³ dane
 0EA  0D001                         TEST s0, 01[LCD_ready_syg]
 0EB  3A0E9                         JUMP C, 0E9[LCD_czy_odebral]
 0EC  2B003                         OUTPUTK 00[LCD_en_reset], 3[LCD_driver_en_port]
 0ED  25000                         RETURN 
 0EE                      LPC_send: ;CALL UART_TX
 0EE  09007                         INPUT s0, 07[LPC_ready_port]                           ;Sprawdza czy LPC mo¿e odbieraæ dane
 0EF  0D001                         TEST s0, 01[LPC_ready_syg]
 0F0                                ;INPUT s5, LPC_ready_port
 0F0                                ;CALL UART_TX
 0F0  320EE                         JUMP Z, 0EE[LPC_send]
 0F1  2DF05                         OUTPUT sF, 05[LPC_data_port]
 0F2  2B016                         OUTPUTK 01[LPC_data_valid_syg], 6[LPC_data_valid_port]
 0F3  09007        LPC_czy_odebral: INPUT s0, 07[LPC_ready_port]                           ;Sprawdza czy LPC odebra³ dane
 0F4  0D001                         TEST s0, 01[LPC_ready_syg]
 0F5  3A0F3                         JUMP C, 0F3[LPC_czy_odebral]
 0F6  2B006                         OUTPUTK 00[LPC_dv_reset], 6[LPC_data_valid_port]
 0F7  25000                         RETURN 
 0F8                         petla: 
 0F8  200DF                         CALL 0DF[UART_TX]
 0F9  220F8                         JUMP 0F8[petla]
 0FA                                ;
 0FA                                ;
 0FA                                ;--------------------------------------------------------------------------------------
 0FA                                ; Routine to attempt to receive one character from the UART Receiver 'uart_rx6'
 0FA                                ;--------------------------------------------------------------------------------------
 0FA                                ;
 0FA                                ; This routine will attempt to receive one character from the 'UART_RX6' macro, and if
 0FA                                ; successful, will return that character in register 's5' and the Zero flag will be
 0FA                                ; reset (Z=0).
 0FA                                ;
 0FA                                ; If there are no characters available to be read from the FIFO buffer within the
 0FA                                ; 'UART_RX6' macro then this routine will timeout after ~2,000 clock cycles (which is
 0FA                                ; 40us at 50MHz) with the Zero flag set (Z=1). This timeout scheme ensures that KCPSM6
 0FA                                ; cannot become stuck in this routine if no characters are received. If you do want
 0FA                                ; KCPSM6 to wait indefinitely for a character to be received then either modify this
 0FA                                ; routine or perform a test of the Zero flag and repeat the call to this routine as
 0FA                                ; shown in this example...
 0FA                                ;
 0FA                                ;          wait_for_UART_RX: CALL UART_RX
 0FA                                ;                            JUMP Z, wait_for_UART_RX
 0FA                                ;
 0FA                                ;
 0FA                                ; Registers used s0, s1 and s5.
 0FA                                ;
 0FA  011A7                UART_RX: LOAD s1, A7[167'd]                                     ;Timeout = 167 x (6 instructions x 2 clock cycles)
 0FB  09000             rx_timeout: INPUT s0, 00[UART_status_port]
 0FC  0D008                         TEST s0, 08[UART_Rx_data_present]                      ;Z=0 and C=1 when data present
 0FD  36101                         JUMP NZ, 101[read_Rx]
 0FE  19101                         SUB s1, 01[1'd]
 0FF  31000                         RETURN Z                                               ;Timeout returns with Z=1 and C=0
 100  220FB                         JUMP 0FB[rx_timeout]
 101                                ;
 101  09501                read_Rx: INPUT s5, 01[UART_RX6_input_port]                      ;read character from buffer
 102  25000                         RETURN 
 103                                ;
 103                                ;
 103                                ;------------------------------------------------------------------------------------------
 103                                ; End of 'uart_interface_routines.psm"'
 103                                ;------------------------------------------------------------------------------------------
 103                                ;
 103                                INCLUDE "C:\studia\MGR\FPGA\mgr\PicoProgram\banners_conversts_send.psm"["banners_conversts_send.psm"]
 103                                CONSTANT code_in_use, 03
 103                                CONSTANT invalid_code, 07
 103                                CONSTANT opening, 01
 103                                CONSTANT no_money, 0F
 103                                CONSTANT other_car, 02
 103                                CONSTANT bad_format, 08
 103                                CONSTANT internal_error, 05
 103                                CONSTANT button0, 3F
 103                                CONSTANT button1, 3D
 103                                CONSTANT button2, 3B
 103                                CONSTANT button3, 39
 103                                CONSTANT button4, 37
 103                                CONSTANT button5, 35
 103                                CONSTANT button6, 33
 103                                CONSTANT button7, 31
 103                                CONSTANT button8, 2F
 103                                CONSTANT button9, 2D
 103                                CONSTANT buttonON, 27
 103                                CONSTANT buttonMute, 25
 103                                CONSTANT buttonUp, 3F
 103                                CONSTANT buttonDown, 3D
 103                                CONSTANT buttonCenter, 09
 103                                CONSTANT buttonLeft, 1D
 103                                CONSTANT buttonRight, 1F
 103                                CONSTANT driveIN, 29
 103                                CONSTANT driveOUT, 2B
 103                         dummy: 
 103  006C0                         LOAD s6, sC
 104  1963F                         SUB s6, 3F[button0]
 105  3A10B                         JUMP C, 10B[next_button1]
 106  0D6FF                         TEST s6, FF[11111111'b]
 107  3610B                         JUMP NZ, 10B[next_button1]
 108  01F30                         LOAD sF, 30["0"]
 109  20032                         CALL 032[LPC_LCD_send]
 10A  25000                         RETURN 
 10B                  convert_send: 
 10B  006C0           next_button1: LOAD s6, sC
 10C  1963D                         SUB s6, 3D[button1]
 10D  3A113                         JUMP C, 113[next_button2]
 10E  0D6FF                         TEST s6, FF[11111111'b]
 10F  36113                         JUMP NZ, 113[next_button2]
 110  01F31                         LOAD sF, 31["1"]
 111  20032                         CALL 032[LPC_LCD_send]
 112  25000                         RETURN 
 113  006C0           next_button2: LOAD s6, sC
 114  1963B                         SUB s6, 3B[button2]
 115  3A11B                         JUMP C, 11B[next_button3]
 116  0D6FF                         TEST s6, FF[11111111'b]
 117  3611B                         JUMP NZ, 11B[next_button3]
 118  01F32                         LOAD sF, 32["2"]
 119  20032                         CALL 032[LPC_LCD_send]
 11A  25000                         RETURN 
 11B  006C0           next_button3: LOAD s6, sC
 11C  19639                         SUB s6, 39[button3]
 11D  3A123                         JUMP C, 123[next_button4]
 11E  0D6FF                         TEST s6, FF[11111111'b]
 11F  36123                         JUMP NZ, 123[next_button4]
 120  01F33                         LOAD sF, 33["3"]
 121  20032                         CALL 032[LPC_LCD_send]
 122  25000                         RETURN 
 123  006C0           next_button4: LOAD s6, sC
 124  19637                         SUB s6, 37[button4]
 125  3A12B                         JUMP C, 12B[next_button5]
 126  0D6FF                         TEST s6, FF[11111111'b]
 127  3612B                         JUMP NZ, 12B[next_button5]
 128  01F34                         LOAD sF, 34["4"]
 129  20032                         CALL 032[LPC_LCD_send]
 12A  25000                         RETURN 
 12B  006C0           next_button5: LOAD s6, sC
 12C  19635                         SUB s6, 35[button5]
 12D  3A133                         JUMP C, 133[next_button6]
 12E  0D6FF                         TEST s6, FF[11111111'b]
 12F  36133                         JUMP NZ, 133[next_button6]
 130  01F35                         LOAD sF, 35["5"]
 131  20032                         CALL 032[LPC_LCD_send]
 132  25000                         RETURN 
 133  006C0           next_button6: LOAD s6, sC
 134  19633                         SUB s6, 33[button6]
 135  3A13B                         JUMP C, 13B[next_button7]
 136  0D6FF                         TEST s6, FF[11111111'b]
 137  3613B                         JUMP NZ, 13B[next_button7]
 138  01F36                         LOAD sF, 36["6"]
 139  20032                         CALL 032[LPC_LCD_send]
 13A  25000                         RETURN 
 13B  006C0           next_button7: LOAD s6, sC
 13C  19631                         SUB s6, 31[button7]
 13D  3A143                         JUMP C, 143[next_button8]
 13E  0D6FF                         TEST s6, FF[11111111'b]
 13F  36143                         JUMP NZ, 143[next_button8]
 140  01F37                         LOAD sF, 37["7"]
 141  20032                         CALL 032[LPC_LCD_send]
 142  25000                         RETURN 
 143  006C0           next_button8: LOAD s6, sC
 144  1962F                         SUB s6, 2F[button8]
 145  3A14B                         JUMP C, 14B[next_button9]
 146  0D6FF                         TEST s6, FF[11111111'b]
 147  3614B                         JUMP NZ, 14B[next_button9]
 148  01F38                         LOAD sF, 38["8"]
 149  20032                         CALL 032[LPC_LCD_send]
 14A  25000                         RETURN 
 14B  006C0           next_button9: LOAD s6, sC
 14C  1962D                         SUB s6, 2D[button9]
 14D  3A153                         JUMP C, 153[next_button10]
 14E  0D6FF                         TEST s6, FF[11111111'b]
 14F  36153                         JUMP NZ, 153[next_button10]
 150  01F39                         LOAD sF, 39["9"]
 151  20032                         CALL 032[LPC_LCD_send]
 152  25000                         RETURN 
 153  006C0          next_button10: LOAD s6, sC
 154  19629                         SUB s6, 29[driveIN]
 155  3A15B                         JUMP C, 15B[next_button11]
 156  0D6FF                         TEST s6, FF[11111111'b]
 157  3615B                         JUMP NZ, 15B[next_button11]
 158  00FC0                         LOAD sF, sC
 159  20032                         CALL 032[LPC_LCD_send]
 15A  25000                         RETURN 
 15B  006C0          next_button11: LOAD s6, sC
 15C  1962B                         SUB s6, 2B[driveOUT]
 15D  3A1A7                         JUMP C, 1A7[just_return]
 15E  0D6FF                         TEST s6, FF[11111111'b]
 15F  361A7                         JUMP NZ, 1A7[just_return]
 160  00FC0                         LOAD sF, sC
 161  20032                         CALL 032[LPC_LCD_send]
 162  25000                         RETURN 
 163  00650           which_banner: LOAD s6, s5
 164  19603                         SUB s6, 03[code_in_use]
 165  3A16C                         JUMP C, 16C[next_banner1]
 166  0D6FF                         TEST s6, FF[11111111'b]
 167  3616C                         JUMP NZ, 16C[next_banner1]
 168  01F1B                         LOAD sF, 1B[ESC]
 169  200E4                         CALL 0E4[LCD_send]
 16A  201AF                         CALL 1AF[banner_message]
 16B  25000                         RETURN 
 16C  00650           next_banner1: LOAD s6, s5
 16D  19601                         SUB s6, 01[opening]
 16E  3A17A                         JUMP C, 17A[next_banner2]
 16F  0D6FF                         TEST s6, FF[11111111'b]
 170  3617A                         JUMP NZ, 17A[next_banner2]
 171  01F1B                         LOAD sF, 1B[ESC]
 172  200E4                         CALL 0E4[LCD_send]
 173  201C1                         CALL 1C1[banner2_message]
 174  0900B  IR_czekaj_na_przejazd: INPUT s0, 0B[IR_PORT]
 175  0D001                         TEST s0, 01[00000001'b]
 176  3A174                         JUMP C, 174[IR_czekaj_na_przejazd]
 177  01F44                         LOAD sF, 44["D"]
 178  200EE                         CALL 0EE[LPC_send]
 179  25000                         RETURN 
 17A  00650           next_banner2: LOAD s6, s5
 17B  19607                         SUB s6, 07[invalid_code]
 17C  3A183                         JUMP C, 183[next_banner3]
 17D  0D6FF                         TEST s6, FF[11111111'b]
 17E  36183                         JUMP NZ, 183[next_banner3]
 17F  01F1B                         LOAD sF, 1B[ESC]
 180  200E4                         CALL 0E4[LCD_send]
 181  201E5                         CALL 1E5[banner3_message]
 182  25000                         RETURN 
 183  00650           next_banner3: LOAD s6, s5
 184  1960F                         SUB s6, 0F[no_money]
 185  3A18C                         JUMP C, 18C[next_banner4]
 186  0D6FF                         TEST s6, FF[11111111'b]
 187  3618C                         JUMP NZ, 18C[next_banner4]
 188  01F1B                         LOAD sF, 1B[ESC]
 189  200E4                         CALL 0E4[LCD_send]
 18A  201FB                         CALL 1FB[banner4_message]
 18B  25000                         RETURN 
 18C  00650           next_banner4: LOAD s6, s5
 18D  19602                         SUB s6, 02[other_car]
 18E  3A195                         JUMP C, 195[next_banner5]
 18F  0D6FF                         TEST s6, FF[11111111'b]
 190  36195                         JUMP NZ, 195[next_banner5]
 191  01F1B                         LOAD sF, 1B[ESC]
 192  200E4                         CALL 0E4[LCD_send]
 193  2021F                         CALL 21F[banner5_message]
 194  25000                         RETURN 
 195  00650           next_banner5: LOAD s6, s5
 196  19608                         SUB s6, 08[bad_format]
 197  3A19E                         JUMP C, 19E[next_banner6]
 198  0D6FF                         TEST s6, FF[11111111'b]
 199  3619E                         JUMP NZ, 19E[next_banner6]
 19A  01F1B                         LOAD sF, 1B[ESC]
 19B  200E4                         CALL 0E4[LCD_send]
 19C  20241                         CALL 241[banner6_message]
 19D  25000                         RETURN 
 19E  00650           next_banner6: LOAD s6, s5
 19F  19605                         SUB s6, 05[internal_error]
 1A0  3A1A7                         JUMP C, 1A7[just_return]
 1A1  0D6FF                         TEST s6, FF[11111111'b]
 1A2  361A7                         JUMP NZ, 1A7[just_return]
 1A3  01F1B                         LOAD sF, 1B[ESC]
 1A4  200E4                         CALL 0E4[LCD_send]
 1A5  20264                         CALL 264[banner7_message]
 1A6  25000                         RETURN 
 1A7  25000            just_return: RETURN 
 1A8                                ;
 1A8                                ;------------------------------------------------------------------------------------------
 1A8                                ; Send a message to the UART
 1A8                                ;------------------------------------------------------------------------------------------
 1A8                                ;
 1A8                                ; A message is transmitted to the USB-UART.
 1A8                                ; The start address of the message must be provided in [sB,sA].
 1A8                                ; Terminate the transmission with a NULL character (00 hex).
 1A8                                ;
 1A8  24BA0           send_message: CALL@ (sB, sA)
 1A9  1D500                         COMPARE s5, 00                                         ;terminate on NUL character
 1AA  31000                         RETURN Z
 1AB  200DF                         CALL 0DF[UART_TX]
 1AC  11A01                         ADD sA, 01[1'd]
 1AD  13B00                         ADDCY sB, 00[0'd]
 1AE  221A8                         JUMP 1A8[send_message]
 1AF                                ;
 1AF                                ;
 1AF                                ;------------------------------------------------------------------------------------------
 1AF                                ; Send Carriage Return to UART
 1AF                                ;------------------------------------------------------------------------------------------
 1AF                                ;
 1AF                                ; Registers used s0, s1, s2, and s5.
 1AF                                ;
 1AF  01B01         banner_message: LOAD sB, 01[banner_msg'upper]
 1B0  01AB4                         LOAD sA, B4[banner_msg'lower]
 1B1  2029F                         CALL 29F[send_banner]
 1B2  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1B3  25000                         RETURN 
 1B4                                ;
 1B4                                STRING bannert$, "Kod w uzyciu"
 1B4                                ;
 1B4                                ;
 1B4  21F4B             banner_msg: LOAD&RETURN sF, 4B[bannert$:"K"]
 1B5  21F6F                         LOAD&RETURN sF, 6F[bannert$:"o"]
 1B6  21F64                         LOAD&RETURN sF, 64[bannert$:"d"]
 1B7  21F20                         LOAD&RETURN sF, 20[bannert$:" "]
 1B8  21F77                         LOAD&RETURN sF, 77[bannert$:"w"]
 1B9  21F20                         LOAD&RETURN sF, 20[bannert$:" "]
 1BA  21F75                         LOAD&RETURN sF, 75[bannert$:"u"]
 1BB  21F7A                         LOAD&RETURN sF, 7A[bannert$:"z"]
 1BC  21F79                         LOAD&RETURN sF, 79[bannert$:"y"]
 1BD  21F63                         LOAD&RETURN sF, 63[bannert$:"c"]
 1BE  21F69                         LOAD&RETURN sF, 69[bannert$:"i"]
 1BF  21F75                         LOAD&RETURN sF, 75[bannert$:"u"]
 1C0  21F00                         LOAD&RETURN sF, 00[NUL]
 1C1                                ;
 1C1                                ;
 1C1                                ;
 1C1  01B01        banner2_message: LOAD sB, 01[banner2_msg'upper]
 1C2  01AC6                         LOAD sA, C6[banner2_msg'lower]
 1C3  2029F                         CALL 29F[send_banner]
 1C4  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1C5  25000                         RETURN 
 1C6                                ;
 1C6                                STRING bannert2$, "     Prosze        przejezdzac"
 1C6                                ;
 1C6                                ;
 1C6  21F20            banner2_msg: LOAD&RETURN sF, 20[bannert2$:" "]
 1C7  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1C8  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1C9  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1CA  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1CB  21F50                         LOAD&RETURN sF, 50[bannert2$:"P"]
 1CC  21F72                         LOAD&RETURN sF, 72[bannert2$:"r"]
 1CD  21F6F                         LOAD&RETURN sF, 6F[bannert2$:"o"]
 1CE  21F73                         LOAD&RETURN sF, 73[bannert2$:"s"]
 1CF  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1D0  21F65                         LOAD&RETURN sF, 65[bannert2$:"e"]
 1D1  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D2  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D3  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D4  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D5  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D6  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D7  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D8  21F20                         LOAD&RETURN sF, 20[bannert2$:" "]
 1D9  21F70                         LOAD&RETURN sF, 70[bannert2$:"p"]
 1DA  21F72                         LOAD&RETURN sF, 72[bannert2$:"r"]
 1DB  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1DC  21F65                         LOAD&RETURN sF, 65[bannert2$:"e"]
 1DD  21F6A                         LOAD&RETURN sF, 6A[bannert2$:"j"]
 1DE  21F65                         LOAD&RETURN sF, 65[bannert2$:"e"]
 1DF  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1E0  21F64                         LOAD&RETURN sF, 64[bannert2$:"d"]
 1E1  21F7A                         LOAD&RETURN sF, 7A[bannert2$:"z"]
 1E2  21F61                         LOAD&RETURN sF, 61[bannert2$:"a"]
 1E3  21F63                         LOAD&RETURN sF, 63[bannert2$:"c"]
 1E4  21F00                         LOAD&RETURN sF, 00[NUL]
 1E5  01B01        banner3_message: LOAD sB, 01[banner3_msg'upper]
 1E6  01AEA                         LOAD sA, EA[banner3_msg'lower]
 1E7  2029F                         CALL 29F[send_banner]
 1E8  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1E9  25000                         RETURN 
 1EA                                ;
 1EA                                STRING bannert3$, " Niewazny  kod  "
 1EA                                ;
 1EA                                ;
 1EA  21F20            banner3_msg: LOAD&RETURN sF, 20[bannert3$:" "]
 1EB  21F4E                         LOAD&RETURN sF, 4E[bannert3$:"N"]
 1EC  21F69                         LOAD&RETURN sF, 69[bannert3$:"i"]
 1ED  21F65                         LOAD&RETURN sF, 65[bannert3$:"e"]
 1EE  21F77                         LOAD&RETURN sF, 77[bannert3$:"w"]
 1EF  21F61                         LOAD&RETURN sF, 61[bannert3$:"a"]
 1F0  21F7A                         LOAD&RETURN sF, 7A[bannert3$:"z"]
 1F1  21F6E                         LOAD&RETURN sF, 6E[bannert3$:"n"]
 1F2  21F79                         LOAD&RETURN sF, 79[bannert3$:"y"]
 1F3  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 1F4  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 1F5  21F6B                         LOAD&RETURN sF, 6B[bannert3$:"k"]
 1F6  21F6F                         LOAD&RETURN sF, 6F[bannert3$:"o"]
 1F7  21F64                         LOAD&RETURN sF, 64[bannert3$:"d"]
 1F8  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 1F9  21F20                         LOAD&RETURN sF, 20[bannert3$:" "]
 1FA  21F00                         LOAD&RETURN sF, 00[NUL]
 1FB  01B02        banner4_message: LOAD sB, 02[banner4_msg'upper]
 1FC  01A00                         LOAD sA, 00[banner4_msg'lower]
 1FD  2029F                         CALL 29F[send_banner]
 1FE  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 1FF  25000                         RETURN 
 200                                ;
 200                                STRING bannert4$, "Twoj abonament  nie jest wazny"
 200                                ;
 200                                ;
 200  21F54            banner4_msg: LOAD&RETURN sF, 54[bannert4$:"T"]
 201  21F77                         LOAD&RETURN sF, 77[bannert4$:"w"]
 202  21F6F                         LOAD&RETURN sF, 6F[bannert4$:"o"]
 203  21F6A                         LOAD&RETURN sF, 6A[bannert4$:"j"]
 204  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 205  21F61                         LOAD&RETURN sF, 61[bannert4$:"a"]
 206  21F62                         LOAD&RETURN sF, 62[bannert4$:"b"]
 207  21F6F                         LOAD&RETURN sF, 6F[bannert4$:"o"]
 208  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 209  21F61                         LOAD&RETURN sF, 61[bannert4$:"a"]
 20A  21F6D                         LOAD&RETURN sF, 6D[bannert4$:"m"]
 20B  21F65                         LOAD&RETURN sF, 65[bannert4$:"e"]
 20C  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 20D  21F74                         LOAD&RETURN sF, 74[bannert4$:"t"]
 20E  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 20F  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 210  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 211  21F69                         LOAD&RETURN sF, 69[bannert4$:"i"]
 212  21F65                         LOAD&RETURN sF, 65[bannert4$:"e"]
 213  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 214  21F6A                         LOAD&RETURN sF, 6A[bannert4$:"j"]
 215  21F65                         LOAD&RETURN sF, 65[bannert4$:"e"]
 216  21F73                         LOAD&RETURN sF, 73[bannert4$:"s"]
 217  21F74                         LOAD&RETURN sF, 74[bannert4$:"t"]
 218  21F20                         LOAD&RETURN sF, 20[bannert4$:" "]
 219  21F77                         LOAD&RETURN sF, 77[bannert4$:"w"]
 21A  21F61                         LOAD&RETURN sF, 61[bannert4$:"a"]
 21B  21F7A                         LOAD&RETURN sF, 7A[bannert4$:"z"]
 21C  21F6E                         LOAD&RETURN sF, 6E[bannert4$:"n"]
 21D  21F79                         LOAD&RETURN sF, 79[bannert4$:"y"]
 21E  21F00                         LOAD&RETURN sF, 00[NUL]
 21F                                ;
 21F  01B02        banner5_message: LOAD sB, 02[banner5_msg'upper]
 220  01A24                         LOAD sA, 24[banner5_msg'lower]
 221  2029F                         CALL 29F[send_banner]
 222  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 223  25000                         RETURN 
 224                                ;
 224                                STRING bannert5$, "Inne Twoje auto juz wjechalo"
 224                                ;
 224                                ;
 224  21F49            banner5_msg: LOAD&RETURN sF, 49[bannert5$:"I"]
 225  21F6E                         LOAD&RETURN sF, 6E[bannert5$:"n"]
 226  21F6E                         LOAD&RETURN sF, 6E[bannert5$:"n"]
 227  21F65                         LOAD&RETURN sF, 65[bannert5$:"e"]
 228  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 229  21F54                         LOAD&RETURN sF, 54[bannert5$:"T"]
 22A  21F77                         LOAD&RETURN sF, 77[bannert5$:"w"]
 22B  21F6F                         LOAD&RETURN sF, 6F[bannert5$:"o"]
 22C  21F6A                         LOAD&RETURN sF, 6A[bannert5$:"j"]
 22D  21F65                         LOAD&RETURN sF, 65[bannert5$:"e"]
 22E  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 22F  21F61                         LOAD&RETURN sF, 61[bannert5$:"a"]
 230  21F75                         LOAD&RETURN sF, 75[bannert5$:"u"]
 231  21F74                         LOAD&RETURN sF, 74[bannert5$:"t"]
 232  21F6F                         LOAD&RETURN sF, 6F[bannert5$:"o"]
 233  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 234  21F6A                         LOAD&RETURN sF, 6A[bannert5$:"j"]
 235  21F75                         LOAD&RETURN sF, 75[bannert5$:"u"]
 236  21F7A                         LOAD&RETURN sF, 7A[bannert5$:"z"]
 237  21F20                         LOAD&RETURN sF, 20[bannert5$:" "]
 238  21F77                         LOAD&RETURN sF, 77[bannert5$:"w"]
 239  21F6A                         LOAD&RETURN sF, 6A[bannert5$:"j"]
 23A  21F65                         LOAD&RETURN sF, 65[bannert5$:"e"]
 23B  21F63                         LOAD&RETURN sF, 63[bannert5$:"c"]
 23C  21F68                         LOAD&RETURN sF, 68[bannert5$:"h"]
 23D  21F61                         LOAD&RETURN sF, 61[bannert5$:"a"]
 23E  21F6C                         LOAD&RETURN sF, 6C[bannert5$:"l"]
 23F  21F6F                         LOAD&RETURN sF, 6F[bannert5$:"o"]
 240  21F00                         LOAD&RETURN sF, 00[NUL]
 241                                ;
 241                                ;
 241                                ;
 241  01B02        banner6_message: LOAD sB, 02[banner6_msg'upper]
 242  01A46                         LOAD sA, 46[banner6_msg'lower]
 243  2029F                         CALL 29F[send_banner]
 244  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 245  25000                         RETURN 
 246                                ;
 246                                STRING bannert6$, "  Nie poprawny    format kodu"
 246                                ;
 246                                ;
 246  21F20            banner6_msg: LOAD&RETURN sF, 20[bannert6$:" "]
 247  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 248  21F4E                         LOAD&RETURN sF, 4E[bannert6$:"N"]
 249  21F69                         LOAD&RETURN sF, 69[bannert6$:"i"]
 24A  21F65                         LOAD&RETURN sF, 65[bannert6$:"e"]
 24B  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 24C  21F70                         LOAD&RETURN sF, 70[bannert6$:"p"]
 24D  21F6F                         LOAD&RETURN sF, 6F[bannert6$:"o"]
 24E  21F70                         LOAD&RETURN sF, 70[bannert6$:"p"]
 24F  21F72                         LOAD&RETURN sF, 72[bannert6$:"r"]
 250  21F61                         LOAD&RETURN sF, 61[bannert6$:"a"]
 251  21F77                         LOAD&RETURN sF, 77[bannert6$:"w"]
 252  21F6E                         LOAD&RETURN sF, 6E[bannert6$:"n"]
 253  21F79                         LOAD&RETURN sF, 79[bannert6$:"y"]
 254  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 255  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 256  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 257  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 258  21F66                         LOAD&RETURN sF, 66[bannert6$:"f"]
 259  21F6F                         LOAD&RETURN sF, 6F[bannert6$:"o"]
 25A  21F72                         LOAD&RETURN sF, 72[bannert6$:"r"]
 25B  21F6D                         LOAD&RETURN sF, 6D[bannert6$:"m"]
 25C  21F61                         LOAD&RETURN sF, 61[bannert6$:"a"]
 25D  21F74                         LOAD&RETURN sF, 74[bannert6$:"t"]
 25E  21F20                         LOAD&RETURN sF, 20[bannert6$:" "]
 25F  21F6B                         LOAD&RETURN sF, 6B[bannert6$:"k"]
 260  21F6F                         LOAD&RETURN sF, 6F[bannert6$:"o"]
 261  21F64                         LOAD&RETURN sF, 64[bannert6$:"d"]
 262  21F75                         LOAD&RETURN sF, 75[bannert6$:"u"]
 263  21F00                         LOAD&RETURN sF, 00[NUL]
 264                                ;
 264                                ;
 264                                ;
 264  01B02        banner7_message: LOAD sB, 02[banner7_msg'upper]
 265  01A69                         LOAD sA, 69[banner7_msg'lower]
 266  2029F                         CALL 29F[send_banner]
 267  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 268  25000                         RETURN 
 269                                ;
 269                                STRING bannert7$, "Blad wewnetrzny  Przepraszamy"
 269                                ;
 269                                ;
 269  21F42            banner7_msg: LOAD&RETURN sF, 42[bannert7$:"B"]
 26A  21F6C                         LOAD&RETURN sF, 6C[bannert7$:"l"]
 26B  21F61                         LOAD&RETURN sF, 61[bannert7$:"a"]
 26C  21F64                         LOAD&RETURN sF, 64[bannert7$:"d"]
 26D  21F20                         LOAD&RETURN sF, 20[bannert7$:" "]
 26E  21F77                         LOAD&RETURN sF, 77[bannert7$:"w"]
 26F  21F65                         LOAD&RETURN sF, 65[bannert7$:"e"]
 270  21F77                         LOAD&RETURN sF, 77[bannert7$:"w"]
 271  21F6E                         LOAD&RETURN sF, 6E[bannert7$:"n"]
 272  21F65                         LOAD&RETURN sF, 65[bannert7$:"e"]
 273  21F74                         LOAD&RETURN sF, 74[bannert7$:"t"]
 274  21F72                         LOAD&RETURN sF, 72[bannert7$:"r"]
 275  21F7A                         LOAD&RETURN sF, 7A[bannert7$:"z"]
 276  21F6E                         LOAD&RETURN sF, 6E[bannert7$:"n"]
 277  21F79                         LOAD&RETURN sF, 79[bannert7$:"y"]
 278  21F20                         LOAD&RETURN sF, 20[bannert7$:" "]
 279  21F20                         LOAD&RETURN sF, 20[bannert7$:" "]
 27A  21F50                         LOAD&RETURN sF, 50[bannert7$:"P"]
 27B  21F72                         LOAD&RETURN sF, 72[bannert7$:"r"]
 27C  21F7A                         LOAD&RETURN sF, 7A[bannert7$:"z"]
 27D  21F65                         LOAD&RETURN sF, 65[bannert7$:"e"]
 27E  21F70                         LOAD&RETURN sF, 70[bannert7$:"p"]
 27F  21F72                         LOAD&RETURN sF, 72[bannert7$:"r"]
 280  21F61                         LOAD&RETURN sF, 61[bannert7$:"a"]
 281  21F73                         LOAD&RETURN sF, 73[bannert7$:"s"]
 282  21F7A                         LOAD&RETURN sF, 7A[bannert7$:"z"]
 283  21F61                         LOAD&RETURN sF, 61[bannert7$:"a"]
 284  21F6D                         LOAD&RETURN sF, 6D[bannert7$:"m"]
 285  21F79                         LOAD&RETURN sF, 79[bannert7$:"y"]
 286  21F00                         LOAD&RETURN sF, 00[NUL]
 287                                ;
 287                                ;
 287                                ;
 287  01B02             ini_banner: LOAD sB, 02[ini_banner_lr'upper]
 288  01A8C                         LOAD sA, 8C[ini_banner_lr'lower]
 289  2029F                         CALL 29F[send_banner]
 28A  14F80                         HWBUILD sF                                             ;hardware version defines ASCII letter
 28B  25000                         RETURN 
 28C                                ;
 28C                                STRING ini_banner_msg$, "Podaj kod wjazdu>>"
 28C                                ;
 28C                                ;
 28C  21F50          ini_banner_lr: LOAD&RETURN sF, 50[ini_banner_msg$:"P"]
 28D  21F6F                         LOAD&RETURN sF, 6F[ini_banner_msg$:"o"]
 28E  21F64                         LOAD&RETURN sF, 64[ini_banner_msg$:"d"]
 28F  21F61                         LOAD&RETURN sF, 61[ini_banner_msg$:"a"]
 290  21F6A                         LOAD&RETURN sF, 6A[ini_banner_msg$:"j"]
 291  21F20                         LOAD&RETURN sF, 20[ini_banner_msg$:" "]
 292  21F6B                         LOAD&RETURN sF, 6B[ini_banner_msg$:"k"]
 293  21F6F                         LOAD&RETURN sF, 6F[ini_banner_msg$:"o"]
 294  21F64                         LOAD&RETURN sF, 64[ini_banner_msg$:"d"]
 295  21F20                         LOAD&RETURN sF, 20[ini_banner_msg$:" "]
 296  21F77                         LOAD&RETURN sF, 77[ini_banner_msg$:"w"]
 297  21F6A                         LOAD&RETURN sF, 6A[ini_banner_msg$:"j"]
 298  21F61                         LOAD&RETURN sF, 61[ini_banner_msg$:"a"]
 299  21F7A                         LOAD&RETURN sF, 7A[ini_banner_msg$:"z"]
 29A  21F64                         LOAD&RETURN sF, 64[ini_banner_msg$:"d"]
 29B  21F75                         LOAD&RETURN sF, 75[ini_banner_msg$:"u"]
 29C  21F3E                         LOAD&RETURN sF, 3E[ini_banner_msg$:">"]
 29D  21F3E                         LOAD&RETURN sF, 3E[ini_banner_msg$:">"]
 29E  21F00                         LOAD&RETURN sF, 00[NUL]
 29F                                ;
 29F                                ;
 29F                                ;
 29F                                ; Send a banner to LCD
 29F                                ;------------------------------------------------------------------------------------------
 29F                                ;
 29F                                ; A message is transmitted to the USB-UART.
 29F                                ; The start address of the message must be provided in [sB,sA].
 29F                                ; Terminate the transmission with a NULL character (00 hex).
 29F                                ;
 29F  24BA0            send_banner: CALL@ (sB, sA)
 2A0  1DF00                         COMPARE sF, 00                                         ;terminate on NUL character
 2A1  31000                         RETURN Z
 2A2                                ;LOAD sF,s5
 2A2  200E4                         CALL 0E4[LCD_send]
 2A3  11A01                         ADD sA, 01[1'd]
 2A4  13B00                         ADDCY sB, 00[0'd]
 2A5  2229F                         JUMP 29F[send_banner]
 2A6                                ;
 2A6                                ;
 2A6                                ;------------------------------------------------------------------------------------------
 2A6                                ; End of Program
 2A6                                ;------------------------------------------------------------------------------------------
 2A6                                ;


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\studia\MGR\FPGA\mgr\PicoProgram\program.psm
C:\studia\MGR\FPGA\mgr\PicoProgram\communication_routines.psm
C:\studia\MGR\FPGA\mgr\PicoProgram\banners_conversts_send.psm



List of defined constants

 CONSTANT name          Value        Source PSM File

 timestamp_hours        17'd         
 timestamp_minutes      00'd         
 timestamp_seconds      23'd         
 datestamp_year         15'd         
 datestamp_month        12'd         
 datestamp_day          05'd         
 NUL                    00           
 BEL                    07           
 BS                     08           
 HT                     09           
 LF                     0A           
 VT                     0B           
 CR                     0D           
 ESC                    1B           
 DEL                    7F           
 DCS                    90           
 ST                     9C           
 hex_value0             00           program.psm
 hex_value1             01           program.psm
 decimal0               02           program.psm
 decimal1               03           program.psm
 decimal2               04           program.psm
 decimal3               05           program.psm
 decimal4               06           program.psm
 UART_status_port       00           communication_routines.psm
 UART_Tx_data_present   00000001'b   communication_routines.psm
 UART_Tx_half_full      00000010'b   communication_routines.psm
 UART_Tx_full           00000100'b   communication_routines.psm
 UART_Rx_data_present   00001000'b   communication_routines.psm
 UART_Rx_half_full      00010000'b   communication_routines.psm
 UART_Rx_full           00100000'b   communication_routines.psm
 UART_TX6_output_port   01           communication_routines.psm
 UART_RX6_input_port    01           communication_routines.psm
 LCD_driver_send_port   02           communication_routines.psm
 LCD_driver_en_port     03           communication_routines.psm
 LCD_driver_ready_port  04           communication_routines.psm
 LPC_data_port          05           communication_routines.psm
 LPC_data_valid_port    06           communication_routines.psm
 LPC_ready_port         07           communication_routines.psm
 LPC_IN_data_port       08           communication_routines.psm
 LPC_IN_data_valid_port 09           communication_routines.psm
 LPC_IN_ready_port      0A           communication_routines.psm
 IR_PORT                0B           communication_routines.psm
 reset_UART_port        01           communication_routines.psm
 UART_tx_reset          00000001'b   communication_routines.psm
 UART_rx_reset          00000010'b   communication_routines.psm
 UART_reset             00000011'b   communication_routines.psm
 UART_operate           00000000'b   communication_routines.psm
 LCD_en_reset           00000000'b   communication_routines.psm
 LCD_en_syg             00000001'b   communication_routines.psm
 LCD_ready_syg          00000001'b   communication_routines.psm
 LCD_odebral_syg        00000000'b   communication_routines.psm
 LPC_ready_syg          00000001'b   communication_routines.psm
 LPC_data_valid_syg     00000001'b   communication_routines.psm
 LPC_dv_reset           00000000'b   communication_routines.psm
 code_in_use            03           banners_conversts_send.psm
 invalid_code           07           banners_conversts_send.psm
 opening                01           banners_conversts_send.psm
 no_money               0F           banners_conversts_send.psm
 other_car              02           banners_conversts_send.psm
 bad_format             08           banners_conversts_send.psm
 internal_error         05           banners_conversts_send.psm
 button0                3F           banners_conversts_send.psm
 button1                3D           banners_conversts_send.psm
 button2                3B           banners_conversts_send.psm
 button3                39           banners_conversts_send.psm
 button4                37           banners_conversts_send.psm
 button5                35           banners_conversts_send.psm
 button6                33           banners_conversts_send.psm
 button7                31           banners_conversts_send.psm
 button8                2F           banners_conversts_send.psm
 button9                2D           banners_conversts_send.psm
 buttonON               27           banners_conversts_send.psm
 buttonMute             25           banners_conversts_send.psm
 buttonUp               3F           banners_conversts_send.psm
 buttonDown             3D           banners_conversts_send.psm
 buttonCenter           09           banners_conversts_send.psm
 buttonLeft             1D           banners_conversts_send.psm
 buttonRight            1F           banners_conversts_send.psm
 driveIN                29           banners_conversts_send.psm
 driveOUT               2B           banners_conversts_send.psm



No TABLEs defined



List of text strings

 STRING name       String                            Source PSM File

 KCPSM6_version$   "v2.70"                           
 datestamp$        "05 Dec 2015"                     
 timestamp$        "17:00:23"                        
 bannert$          "Kod w uzyciu"                    banners_conversts_send.psm
 bannert2$         "     Prosze        przejezdzac"  banners_conversts_send.psm
 bannert3$         " Niewazny  kod  "                banners_conversts_send.psm
 bannert4$         "Twoj abonament  nie jest wazny"  banners_conversts_send.psm
 bannert5$         "Inne Twoje auto juz wjechalo"    banners_conversts_send.psm
 bannert6$         "  Nie poprawny    format kodu"   banners_conversts_send.psm
 bannert7$         "Blad wewnetrzny  Przepraszamy"   banners_conversts_send.psm
 ini_banner_msg$   "Podaj kod wjazdu>>"              banners_conversts_send.psm



List of line labels

   Label                   Addr  Source PSM File

 * cold_start              000   program.psm
 * main                    002   program.psm
   IR_petla1               002   program.psm
   IR_petla2               006   program.psm
   IR_czekaj               009   program.psm
 * IR_rx1                  00D   program.psm
   next_IR_bit1            00E   program.psm
 * IR_rx2                  014   program.psm
   next_IR_bit2            015   program.psm
 * IR_rx3                  01B   program.psm
   next_IR_bit3            01C   program.psm
   LPC_THREAD              026   program.psm
   LPC_DV_down             02B   program.psm
   LPC_LCD_send            032   program.psm
   UART_THREAD             036   program.psm
   send_CR                 03E   program.psm
 * send_space              040   program.psm
 * send_hex_byte           042   program.psm
   hex_to_ASCII            04E   program.psm
   number_char             051   program.psm
   upper_case              053   program.psm
   ASCII_to_hex            059   program.psm
   ASCII_letter            063   program.psm
 * obtain_value            065   program.psm
   obtain_digit            066   program.psm
   build_value             06F   program.psm
 * send_integer            079   program.psm
   send_integer_loop       07F   program.psm
   next_int_digit          085   program.psm
   zero_integer            089   program.psm
   integer16_to_BCD        08C   program.psm
   int_to_BCD_loop         08D   program.psm
   divide_16bit_by_10      093   program.psm
   div10_loop              09A   program.psm
   div10_restore           09F   program.psm
   div10_shifts            0A2   program.psm
   my_delay_ir_bit         0A8   program.psm
 * delay_ir_bit            0AC   program.psm
 * delay_ir_half_bit       0B0   program.psm
   delay_ir_1_8_bit        0B4   program.psm
 * delay_200ms             0B8   program.psm
   delay_1s                0BC   program.psm
 * delay_1ms               0C0   program.psm
 * delay_40ms              0C4   program.psm
 * delay_2s                0C8   program.psm
   delay_5s                0CC   program.psm
   software_delay          0D2   program.psm
   reset_UART_macros       0D8   communication_routines.psm
 * reset_lcd_en_status     0DB   communication_routines.psm
 * reset_Eth_en_status     0DD   communication_routines.psm
   UART_TX                 0DF   communication_routines.psm
   LCD_send                0E4   communication_routines.psm
   LCD_czy_odebral         0E9   communication_routines.psm
   LPC_send                0EE   communication_routines.psm
   LPC_czy_odebral         0F3   communication_routines.psm
   petla                   0F8   communication_routines.psm
   UART_RX                 0FA   communication_routines.psm
   rx_timeout              0FB   communication_routines.psm
   read_Rx                 101   communication_routines.psm
 * dummy                   103   banners_conversts_send.psm
   convert_send            10B   banners_conversts_send.psm
   next_button1            10B   banners_conversts_send.psm
   next_button2            113   banners_conversts_send.psm
   next_button3            11B   banners_conversts_send.psm
   next_button4            123   banners_conversts_send.psm
   next_button5            12B   banners_conversts_send.psm
   next_button6            133   banners_conversts_send.psm
   next_button7            13B   banners_conversts_send.psm
   next_button8            143   banners_conversts_send.psm
   next_button9            14B   banners_conversts_send.psm
   next_button10           153   banners_conversts_send.psm
   next_button11           15B   banners_conversts_send.psm
   which_banner            163   banners_conversts_send.psm
   next_banner1            16C   banners_conversts_send.psm
   IR_czekaj_na_przejazd   174   banners_conversts_send.psm
   next_banner2            17A   banners_conversts_send.psm
   next_banner3            183   banners_conversts_send.psm
   next_banner4            18C   banners_conversts_send.psm
   next_banner5            195   banners_conversts_send.psm
   next_banner6            19E   banners_conversts_send.psm
   just_return             1A7   banners_conversts_send.psm
   send_message            1A8   banners_conversts_send.psm
   banner_message          1AF   banners_conversts_send.psm
   banner_msg              1B4   banners_conversts_send.psm
   banner2_message         1C1   banners_conversts_send.psm
   banner2_msg             1C6   banners_conversts_send.psm
   banner3_message         1E5   banners_conversts_send.psm
   banner3_msg             1EA   banners_conversts_send.psm
   banner4_message         1FB   banners_conversts_send.psm
   banner4_msg             200   banners_conversts_send.psm
   banner5_message         21F   banners_conversts_send.psm
   banner5_msg             224   banners_conversts_send.psm
   banner6_message         241   banners_conversts_send.psm
   banner6_msg             246   banners_conversts_send.psm
   banner7_message         264   banners_conversts_send.psm
   banner7_msg             269   banners_conversts_send.psm
   ini_banner              287   banners_conversts_send.psm
   ini_banner_lr           28C   banners_conversts_send.psm
   send_banner             29F   banners_conversts_send.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            111
 STAR              -

 AND               2
 OR                1
 XOR               -

 ADD              11
 ADDCY             3
 SUB              34
 SUBCY             3

 TEST             33
 TESTCY            -
 COMPARE           8
 COMPARECY         1

 SL0               2
 SL1               1
 SLX               -
 SLA               7
 RL                -
 SR0               5
 SR1               -
 SRX               -
 SRA               1
 RR                -

 REGBANK           -

 INPUT            17
 OUTPUT            3
 OUTPUTK          10

 STORE             1
 FETCH             1

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             83
 JUMP@             -
 CALL             73
 CALL@             2
 RETURN           57
 LOAD&RETURN     200

 HWBUILD           8



End of KCPSM6 log file.
